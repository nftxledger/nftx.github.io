{"version":3,"file":"static/chunks/440-e3e6a3c56d00902d.js","mappings":"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","sources":["webpack://_N_E/../../node_modules/next/dist/client/get-domain-locale.js","webpack://_N_E/../../node_modules/next/dist/client/link.js","webpack://_N_E/../../node_modules/next/dist/client/use-intersection.js","webpack://_N_E/../../node_modules/next/link.js","webpack://_N_E/../../node_modules/react-relay/index.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayContainerUtils.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayContext.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayFragmentContainer.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayLocalQueryRenderer.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayPaginationContainer.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayQueryFetcher.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayQueryRenderer.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayQueryRendererContext.js","webpack://_N_E/../../node_modules/react-relay/lib/ReactRelayRefetchContainer.js","webpack://_N_E/../../node_modules/react-relay/lib/RelayContext.js","webpack://_N_E/../../node_modules/react-relay/lib/assertFragmentMap.js","webpack://_N_E/../../node_modules/react-relay/lib/buildReactRelayContainer.js","webpack://_N_E/../../node_modules/react-relay/lib/getRootVariablesForFragments.js","webpack://_N_E/../../node_modules/react-relay/lib/index.js","webpack://_N_E/../../node_modules/react-relay/lib/isRelayEnvironment.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/FragmentResource.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/HooksImplementation.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/LRUCache.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/ProfilerContext.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/QueryResource.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/SuspenseResource.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/loadQuery.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useClientQuery.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useFragment.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useFragmentNode.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useMemoVariables.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useMutation.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useQueryLoader.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentNode.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useSubscription.js","webpack://_N_E/../../node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js","webpack://_N_E/../../node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://_N_E/../../node_modules/@babel/runtime/helpers/extends.js","webpack://_N_E/../../node_modules/@babel/runtime/helpers/inheritsLoose.js","webpack://_N_E/../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack://_N_E/../../node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://_N_E/<anon>"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getDomainLocale = getDomainLocale;\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const normalizeLocalePath = require('./normalize-locale-path').normalizeLocalePath;\n        const detectDomainLocale = require('./detect-domain-locale').detectDomainLocale;\n        const target = locale || normalizeLocalePath(path, locales).detectedLocale;\n        const domain = detectDomainLocale(domainLocales, undefined, target);\n        if (domain) {\n            const proto = `http${domain.http ? '' : 's'}://`;\n            const finalLocale = target === domain.defaultLocale ? '' : `/${target}`;\n            return `${proto}${domain.domain}${basePath}${finalLocale}${path}`;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=get-domain-locale.js.map","\"use client\";\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\nvar _react = _interop_require_default(require(\"react\"));\nvar _resolveHref = require(\"../shared/lib/router/utils/resolve-href\");\nvar _isLocalUrl = require(\"../shared/lib/router/utils/is-local-url\");\nvar _formatUrl = require(\"../shared/lib/router/utils/format-url\");\nvar _utils = require(\"../shared/lib/utils\");\nvar _addLocale = require(\"./add-locale\");\nvar _routerContext = require(\"../shared/lib/router-context\");\nvar _appRouterContext = require(\"../shared/lib/app-router-context\");\nvar _useIntersection = require(\"./use-intersection\");\nvar _getDomainLocale = require(\"./get-domain-locale\");\nvar _addBasePath = require(\"./add-base-path\");\n\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, isAppRouter) {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = // Let the link's locale prop override the default router locale.\n        typeof options.locale !== 'undefined' ? options.locale : 'locale' in router ? router.locale : undefined;\n        const prefetchedKey = href + '%' + as + '%' + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(router.prefetch(href, as, options)).catch((err)=>{\n        if (process.env.NODE_ENV !== 'production') {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName  } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        if ('beforePopState' in router) {\n            router[replace ? 'replace' : 'push'](href, as, {\n                shallow,\n                locale,\n                scroll\n            });\n        } else {\n            router[replace ? 'replace' : 'push'](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled\n            });\n        }\n    };\n    if (isAppRouter) {\n        // @ts-expect-error startTransition exists.\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formatUrl).formatUrl(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _react.default.forwardRef(function LinkComponent(props, forwardedRef) {\n    if (process.env.NODE_ENV !== 'production') {\n        function createPropError(args) {\n            return new Error(`Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` + (typeof window !== 'undefined' ? \"\\nOpen your browser's console to view the Component stack trace.\" : ''));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'locale') {\n                if (props[key] && valType !== 'string') {\n                    throw createPropError({\n                        key,\n                        expected: '`string`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch' || key === 'legacyBehavior') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');\n        }\n    }\n    let children;\n    const { href: hrefProp , as: asProp , children: childrenProp , prefetch: prefetchProp , passHref , replace , shallow , scroll , locale , onClick , onMouseEnter: onMouseEnterProp , onTouchStart: onTouchStartProp , // @ts-expect-error this is inlined as a literal boolean not a string\n    legacyBehavior =process.env.__NEXT_NEW_LINK_BEHAVIOR === false  } = props, restProps = _object_without_properties_loose(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const prefetchEnabled = prefetchProp !== false;\n    const pagesRouter = _react.default.useContext(_routerContext.RouterContext);\n    const appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    if (process.env.NODE_ENV !== 'production') {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw new Error(`Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`);\n                }\n            }\n        }\n    }\n    const { href , as  } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolveHref).resolveHref(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (process.env.NODE_ENV === 'development') {\n            if (onClick) {\n                console.warn(`\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`);\n            }\n            if (onMouseEnterProp) {\n                console.warn(`\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(`No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`);\n                }\n                throw new Error(`Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? \" \\nOpen your browser's console to view the Component stack trace.\" : ''));\n            }\n        } else {\n            child = _react.default.Children.only(children);\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            var ref;\n            if (((ref = children) == null ? void 0 : ref.type) === 'a') {\n                throw new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor');\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useIntersection).useIntersection({\n        rootMargin: '200px'\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === 'function') childRef(el);\n            else if (typeof childRef === 'object') {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (process.env.NODE_ENV !== 'production') {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter, \n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!e) {\n                    throw new Error(`Component rendered inside next/link has to pass click event to \"onClick\" prop.`);\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils).isAbsoluteUrl(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        const curLocale = typeof locale !== 'undefined' ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getDomainLocale).getDomainLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n});\nvar _default = Link;\nexports.default = _default;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=link.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.useIntersection = useIntersection;\nvar _react = require(\"react\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nconst hasIntersectionObserver = typeof IntersectionObserver === 'function';\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || ''\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection({ rootRef , rootMargin , disabled  }) {\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react).useState(false);\n    const elementRef = (0, _react).useRef(null);\n    const setElement = (0, _react).useCallback((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react).useEffect(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true));\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react).useCallback(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=use-intersection.js.map","module.exports = require('./dist/client/link')\n","/**\n * Relay v15.0.0\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = require('./lib/index.js');\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nfunction getComponentName(component) {\n  return component.displayName || component.name || 'Component';\n}\nfunction getContainerName(Component) {\n  return 'Relay(' + getComponentName(Component) + ')';\n}\nmodule.exports = {\n  getComponentName: getComponentName,\n  getContainerName: getContainerName\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  createRelayContext = _require.__internal.createRelayContext;\nmodule.exports = createRelayContext(React);","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _excluded = [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"];\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\nvar _require = require('./ReactRelayContainerUtils'),\n  getContainerName = _require.getContainerName;\nvar _require2 = require('./RelayContext'),\n  assertRelayContext = _require2.assertRelayContext;\nvar areEqual = require(\"fbjs/lib/areEqual\");\nvar React = require('react');\nvar _require3 = require('relay-runtime'),\n  createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n  getDataIDsFromObject = _require3.getDataIDsFromObject,\n  isScalarAndEqual = _require3.isScalarAndEqual;\n/**\n * Composes a React component class, returning a new class that intercepts\n * props, resolving them with the provided fragments and subscribing for\n * updates.\n */\nfunction createContainerWithFragments(Component, fragments) {\n  var _class;\n  var containerName = getContainerName(Component);\n  return _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n    // $FlowFixMe[missing-local-annot]\n\n    function _class(props) {\n      var _props$__rootIsQueryR, _this;\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        var resolverFromThisUpdate = _this.state.resolver;\n        _this.setState(function (updatedState) {\n          return (\n            // If this event belongs to the current data source, update.\n            // Otherwise we should ignore it.\n            resolverFromThisUpdate === updatedState.resolver ? {\n              data: updatedState.resolver.resolve(),\n              relayProp: getRelayProp(updatedState.relayProp.environment)\n            } : null\n          );\n        });\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;\n      // Do not provide a subscription/callback here.\n      // It is possible for this render to be interrupted or aborted,\n      // In which case the subscription would cause a leak.\n      // We will add the subscription in componentDidMount().\n      var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);\n      _this.state = {\n        data: resolver.resolve(),\n        prevProps: props,\n        prevPropsContext: relayContext,\n        relayProp: getRelayProp(relayContext.environment),\n        resolver: resolver\n      };\n      return _this;\n    }\n\n    /**\n     * When new props are received, read data for the new props and subscribe\n     * for updates. Props may be the same in which case previous data and\n     * subscriptions can be reused.\n     */\n    _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      var _nextProps$__rootIsQu;\n      // Any props change could impact the query, so we mirror props in state.\n      // This is an unusual pattern, but necessary for this container usecase.\n      var prevProps = prevState.prevProps;\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;\n      var prevIDs = getDataIDsFromObject(fragments, prevProps);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var resolver = prevState.resolver;\n\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevIDs, nextIDs)) {\n        // Do not provide a subscription/callback here.\n        // It is possible for this render to be interrupted or aborted,\n        // In which case the subscription would cause a leak.\n        // We will add the subscription in componentDidUpdate().\n        resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);\n        return {\n          data: resolver.resolve(),\n          prevPropsContext: relayContext,\n          prevProps: nextProps,\n          relayProp: getRelayProp(relayContext.environment),\n          resolver: resolver\n        };\n      } else {\n        resolver.setProps(nextProps);\n        var data = resolver.resolve();\n        if (data !== prevState.data) {\n          return {\n            data: data,\n            prevProps: nextProps,\n            prevPropsContext: relayContext,\n            relayProp: getRelayProp(relayContext.environment)\n          };\n        }\n      }\n      return null;\n    };\n    var _proto = _class.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n      this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      if (this.state.resolver !== prevState.resolver) {\n        prevState.resolver.dispose();\n        this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n      } else {\n        this._rerenderIfStoreHasChanged();\n      }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this.state.resolver.dispose();\n    };\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data) {\n        return true;\n      }\n      // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n      var keys = Object.keys(nextProps);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        if (key === '__relayContext') {\n          if (nextState.prevPropsContext.environment !== this.state.prevPropsContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Render new data for the existing props/context.\n     */;\n    _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {\n      var _this$state = this.state,\n        data = _this$state.data,\n        resolver = _this$state.resolver;\n      // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n      var maybeNewData = resolver.resolve();\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n    _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {\n      var _this$state2 = this.state,\n        data = _this$state2.data,\n        resolver = _this$state2.resolver;\n      var maybeNewData = resolver.resolve();\n\n      // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n      resolver.setCallback(this.props, this._handleFragmentDataUpdate);\n\n      // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n\n    // $FlowFixMe[missing-local-annot]\n    ;\n    _proto.render = function render() {\n      // eslint-disable-next-line no-unused-vars\n      var _this$props = this.props,\n        componentRef = _this$props.componentRef,\n        __relayContext = _this$props.__relayContext,\n        __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer,\n        props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, _excluded);\n      return React.createElement(Component, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, props), this.state.data), {}, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      }));\n    };\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _class;\n}\nfunction getRelayProp(environment) {\n  return {\n    environment: environment\n  };\n}\n\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\nfunction createContainer(Component, fragmentSpec) {\n  // $FlowFixMe[incompatible-return]\n  return buildReactRelayContainer(Component, fragmentSpec, createContainerWithFragments);\n}\nmodule.exports = {\n  createContainer: createContainer\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar ReactRelayContext = require('./ReactRelayContext');\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\nvar areEqual = require(\"fbjs/lib/areEqual\");\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  createOperationDescriptor = _require.createOperationDescriptor,\n  deepFreeze = _require.deepFreeze,\n  getRequest = _require.getRequest;\nvar useLayoutEffect = React.useLayoutEffect,\n  useState = React.useState,\n  useRef = React.useRef,\n  useMemo = React.useMemo;\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\nfunction useDeepCompare(value) {\n  var latestValue = React.useRef(value);\n  if (!areEqual(latestValue.current, value)) {\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(value);\n    }\n    latestValue.current = value;\n  }\n  return latestValue.current;\n}\nfunction ReactRelayLocalQueryRenderer(props) {\n  var environment = props.environment,\n    query = props.query,\n    variables = props.variables,\n    render = props.render;\n  var latestVariables = useDeepCompare(variables);\n  var operation = useMemo(function () {\n    var request = getRequest(query);\n    return createOperationDescriptor(request, latestVariables);\n  }, [query, latestVariables]);\n  var relayContext = useMemo(function () {\n    return {\n      environment: environment\n    };\n  }, [environment]);\n\n  // Use a ref to prevent rendering twice when data changes\n  // because of props change\n  var dataRef = useRef(null);\n  var _useState = useState(null),\n    forceUpdate = _useState[1];\n  var cleanupFnRef = useRef(null);\n  var snapshot = useMemo(function () {\n    environment.check(operation);\n    var res = environment.lookup(operation.fragment);\n    dataRef.current = res.data;\n\n    // Run effects here so that the data can be retained\n    // and subscribed before the component commits\n    var retainDisposable = environment.retain(operation);\n    var subscribeDisposable = environment.subscribe(res, function (newSnapshot) {\n      dataRef.current = newSnapshot.data;\n      forceUpdate(dataRef.current);\n    });\n    var disposed = false;\n    function nextCleanupFn() {\n      if (!disposed) {\n        disposed = true;\n        cleanupFnRef.current = null;\n        retainDisposable.dispose();\n        subscribeDisposable.dispose();\n      }\n    }\n    if (cleanupFnRef.current) {\n      cleanupFnRef.current();\n    }\n    cleanupFnRef.current = nextCleanupFn;\n    return res;\n  }, [environment, operation]);\n  useLayoutEffect(function () {\n    var cleanupFn = cleanupFnRef.current;\n    return function () {\n      cleanupFn && cleanupFn();\n    };\n  }, [snapshot]);\n  return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n    value: relayContext\n  }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n    value: queryRendererContext\n  }, render({\n    props: dataRef.current\n  })));\n}\nmodule.exports = ReactRelayLocalQueryRenderer;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _objectSpread3 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _excluded = [\"componentRef\"],\n  _excluded2 = [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"],\n  _excluded3 = [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"];\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\nvar getRootVariablesForFragments = require('./getRootVariablesForFragments');\nvar _require = require('./ReactRelayContainerUtils'),\n  getComponentName = _require.getComponentName,\n  getContainerName = _require.getContainerName;\nvar ReactRelayContext = require('./ReactRelayContext');\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\nvar _require2 = require('./RelayContext'),\n  assertRelayContext = _require2.assertRelayContext;\nvar areEqual = require(\"fbjs/lib/areEqual\");\nvar invariant = require('invariant');\nvar React = require('react');\nvar _require3 = require('relay-runtime'),\n  ConnectionInterface = _require3.ConnectionInterface,\n  Observable = _require3.Observable,\n  RelayFeatureFlags = _require3.RelayFeatureFlags,\n  createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n  createOperationDescriptor = _require3.createOperationDescriptor,\n  getDataIDsFromObject = _require3.getDataIDsFromObject,\n  getRequest = _require3.getRequest,\n  getVariablesFromObject = _require3.getVariablesFromObject,\n  isScalarAndEqual = _require3.isScalarAndEqual;\nvar warning = require(\"fbjs/lib/warning\");\nvar FORWARD = 'forward';\n/**\n * Extends the functionality of RelayFragmentContainer by providing a mechanism\n * to load more data from a connection.\n *\n * # Configuring a PaginationContainer\n *\n * PaginationContainer accepts the standard FragmentContainer arguments and an\n * additional `connectionConfig` argument:\n *\n * - `Component`: the component to be wrapped/rendered.\n * - `fragments`: an object whose values are `graphql` fragments. The object\n *   keys determine the prop names by which fragment data is available.\n * - `connectionConfig`: an object that determines how to load more connection\n *   data. Details below.\n *\n * # Loading More Data\n *\n * Use `props.relay.hasMore()` to determine if there are more items to load.\n *\n * ```\n * hasMore(): boolean\n * ```\n *\n * Use `props.relay.isLoading()` to determine if a previous call to `loadMore()`\n * is still pending. This is convenient for avoiding duplicate load calls.\n *\n * ```\n * isLoading(): boolean\n * ```\n *\n * Use `props.relay.loadMore()` to load more items. This will return null if\n * there are no more items to fetch, otherwise it will fetch more items and\n * return a Disposable that can be used to cancel the fetch.\n *\n * `pageSize` should be the number of *additional* items to fetch (not the\n * total).\n *\n * ```\n * loadMore(pageSize: number, callback: ?(error: ?Error) => void): ?Disposable\n * ```\n *\n * A complete example:\n *\n * ```\n * class Foo extends React.Component {\n *   ...\n *   _onEndReached() {\n *     if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {\n *       return;\n *     }\n *     this.props.relay.loadMore(10);\n *   }\n *   ...\n * }\n * ```\n *\n * # Connection Config\n *\n * Here's an example, followed by details of each config property:\n *\n * ```\n * ReactRelayPaginationContainer.createContainer(\n *   Component,\n *   {\n *     user: graphql`fragment FriendsFragment on User {\n *       friends(after: $afterCursor first: $count) @connection {\n *         edges { ... }\n *         pageInfo {\n *           startCursor\n *           endCursor\n *           hasNextPage\n *           hasPreviousPage\n *         }\n *       }\n *     }`,\n *   },\n *   {\n *     direction: 'forward',\n *     getConnectionFromProps(props) {\n *       return props.user && props.user.friends;\n *     },\n *     getFragmentVariables(vars, totalCount) {\n *       // The component presumably wants *all* edges, not just those after\n *       // the cursor, so notice that we don't set $afterCursor here.\n *       return {\n *         ...vars,\n *         count: totalCount,\n *       };\n *     },\n *     getVariables(props, {count, cursor}, fragmentVariables) {\n *       return {\n *         id: props.user.id,\n *         afterCursor: cursor,\n *         count,\n *       },\n *     },\n *     query: graphql`\n *       query FriendsQuery($id: ID!, $afterCursor: ID, $count: Int!) {\n *         node(id: $id) {\n *           ...FriendsFragment\n *         }\n *       }\n *     `,\n *   }\n * );\n * ```\n *\n * ## Config Properties\n *\n * - `direction`: Either \"forward\" to indicate forward pagination using\n *   after/first, or \"backward\" to indicate backward pagination using\n *   before/last.\n * - `getConnectionFromProps(props)`: PaginationContainer doesn't magically know\n *   which connection data you mean to fetch more of (a container might fetch\n *   multiple connections, but can only paginate one of them). This function is\n *   given the fragment props only (not full props), and should return the\n *   connection data. See the above example that returns the friends data via\n *   `props.user.friends`.\n * - `getFragmentVariables(previousVars, totalCount)`: Given the previous variables\n *   and the new total number of items, get the variables to use when reading\n *   your fragments. Typically this means setting whatever your local \"count\"\n *   variable is to the value of `totalCount`. See the example.\n * - `getVariables(props, {count, cursor})`: Get the variables to use when\n *   fetching the pagination `query`. You may determine the root object id from\n *   props (see the example that uses `props.user.id`) and may also set whatever\n *   variables you use for the after/first/before/last calls based on the count\n *   and cursor.\n * - `query`: A query to use when fetching more connection data. This should\n *   typically reference one of the container's fragment (as in the example)\n *   to ensure that all the necessary fields for sub-components are fetched.\n */\n\nfunction createGetConnectionFromProps(metadata) {\n  var path = metadata.path;\n  !path ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : invariant(false) : void 0;\n  return function (props) {\n    var data = props[metadata.fragmentName];\n    for (var i = 0; i < path.length; i++) {\n      if (!data || typeof data !== 'object') {\n        return null;\n      }\n      data = data[path[i]];\n    }\n    return data;\n  };\n}\nfunction createGetFragmentVariables(metadata) {\n  var countVariable = metadata.count;\n  !countVariable ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : invariant(false) : void 0;\n  return function (prevVars, totalCount) {\n    return (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, prevVars), {}, (0, _defineProperty2[\"default\"])({}, countVariable, totalCount));\n  };\n}\nfunction findConnectionMetadata(fragments) {\n  var foundConnectionMetadata = null;\n  var isRelayModern = false;\n  for (var fragmentName in fragments) {\n    var fragment = fragments[fragmentName];\n    var connectionMetadata = fragment.metadata && fragment.metadata.connection;\n    // HACK: metadata is always set to `undefined` in classic. In modern, even\n    // if empty, it is set to null (never undefined). We use that knowlege to\n    // check if we're dealing with classic or modern\n    if (fragment.metadata !== undefined) {\n      isRelayModern = true;\n    }\n    if (connectionMetadata) {\n      !(connectionMetadata.length === 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', fragmentName, connectionMetadata.length) : invariant(false) : void 0;\n      !!foundConnectionMetadata ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : invariant(false) : void 0;\n      foundConnectionMetadata = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, connectionMetadata[0]), {}, {\n        fragmentName: fragmentName\n      });\n    }\n  }\n  !(!isRelayModern || foundConnectionMetadata !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : invariant(false) : void 0;\n  return foundConnectionMetadata || {};\n}\nfunction toObserver(observerOrCallback) {\n  return typeof observerOrCallback === 'function' ? {\n    error: observerOrCallback,\n    complete: observerOrCallback,\n    unsubscribe: function unsubscribe(subscription) {\n      typeof observerOrCallback === 'function' && observerOrCallback();\n    }\n  } : observerOrCallback || {};\n}\nfunction createContainerWithFragments(Component, fragments, connectionConfig) {\n  var _class;\n  var componentName = getComponentName(Component);\n  var containerName = getContainerName(Component);\n  var metadata = findConnectionMetadata(fragments);\n  var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);\n  var direction = connectionConfig.direction || metadata.direction;\n  !direction ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : invariant(false) : void 0;\n  var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);\n  return _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n    // $FlowFixMe[missing-local-annot]\n\n    function _class(props) {\n      var _props$__rootIsQueryR, _this;\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        _this.setState({\n          data: _this._resolver.resolve()\n        });\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_hasMore\", function () {\n        var connectionData = _this._getConnectionData();\n        return !!(connectionData && connectionData.hasMore && connectionData.cursor);\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_isLoading\", function () {\n        return !!_this._refetchSubscription;\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_refetchConnection\", function (totalCount, observerOrCallback, refetchVariables) {\n        if (!_this._canFetchPage('refetchConnection')) {\n          return {\n            dispose: function dispose() {}\n          };\n        }\n        _this._refetchVariables = refetchVariables;\n        var paginatingVariables = {\n          count: totalCount,\n          cursor: null,\n          totalCount: totalCount\n        };\n        var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {\n          force: true\n        });\n        return {\n          dispose: fetch.unsubscribe\n        };\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_loadMore\", function (pageSize, observerOrCallback, options) {\n        if (!_this._canFetchPage('loadMore')) {\n          return {\n            dispose: function dispose() {}\n          };\n        }\n        var observer = toObserver(observerOrCallback);\n        var connectionData = _this._getConnectionData();\n        if (!connectionData) {\n          Observable.create(function (sink) {\n            return sink.complete();\n          }).subscribe(observer);\n          return null;\n        }\n        var totalCount = connectionData.edgeCount + pageSize;\n        if (options && options.force) {\n          return _this._refetchConnection(totalCount, observerOrCallback);\n        }\n        var _ConnectionInterface$ = ConnectionInterface.get(),\n          END_CURSOR = _ConnectionInterface$.END_CURSOR,\n          START_CURSOR = _ConnectionInterface$.START_CURSOR;\n        var cursor = connectionData.cursor;\n        process.env.NODE_ENV !== \"production\" ? warning(cursor != null && cursor !== '', 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        var paginatingVariables = {\n          count: pageSize,\n          cursor: cursor,\n          totalCount: totalCount\n        };\n        var fetch = _this._fetchPage(paginatingVariables, observer, options);\n        return {\n          dispose: fetch.unsubscribe\n        };\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;\n      _this._isARequestInFlight = false;\n      _this._refetchSubscription = null;\n      _this._refetchVariables = null;\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);\n      } else {\n        _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer, _this._handleFragmentDataUpdate);\n      }\n      _this.state = {\n        data: _this._resolver.resolve(),\n        prevContext: relayContext,\n        contextForChildren: relayContext,\n        relayProp: _this._buildRelayProp(relayContext),\n        resolverGeneration: 0\n      };\n      _this._isUnmounted = false;\n      _this._hasFetched = false;\n      return _this;\n    }\n    var _proto = _class.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n      this._isUnmounted = false;\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n      }\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n        if (prevState.resolverGeneration !== this.state.resolverGeneration) {\n          this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n        } else {\n          this._rerenderIfStoreHasChanged();\n        }\n      }\n    }\n\n    /**\n     * When new props are received, read data for the new props and subscribe\n     * for updates. Props may be the same in which case previous data and\n     * subscriptions can be reused.\n     */;\n    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n      var _nextProps$__rootIsQu;\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;\n      var prevIDs = getDataIDsFromObject(fragments, this.props);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var prevRootVariables = getRootVariablesForFragments(fragments, this.props);\n      var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);\n\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (relayContext.environment !== this.state.prevContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {\n        this._cleanup();\n        // Child containers rely on context.relay being mutated (for gDSFP).\n        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n          this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);\n        } else {\n          this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer, this._handleFragmentDataUpdate);\n        }\n        this.setState(function (prevState) {\n          return {\n            prevContext: relayContext,\n            contextForChildren: relayContext,\n            relayProp: _this2._buildRelayProp(relayContext),\n            resolverGeneration: prevState.resolverGeneration + 1\n          };\n        });\n      } else if (!this._hasFetched) {\n        this._resolver.setProps(nextProps);\n      }\n      var data = this._resolver.resolve();\n      if (data !== this.state.data) {\n        this.setState({\n          data: data\n        });\n      }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._isUnmounted = true;\n      this._cleanup();\n    };\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp || nextState.resolverGeneration !== this.state.resolverGeneration) {\n        return true;\n      }\n      // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n      var keys = Object.keys(nextProps);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        if (key === '__relayContext') {\n          if (nextState.prevContext.environment !== this.state.prevContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    _proto._buildRelayProp = function _buildRelayProp(relayContext) {\n      return {\n        hasMore: this._hasMore,\n        isLoading: this._isLoading,\n        loadMore: this._loadMore,\n        refetchConnection: this._refetchConnection,\n        environment: relayContext.environment\n      };\n    };\n    _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {\n      var data = this.state.data;\n      // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n      var maybeNewData = this._resolver.resolve();\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n    _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {\n      var data = this.state.data;\n      var maybeNewData = this._resolver.resolve();\n\n      // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n      this._resolver.setCallback(this.props, this._handleFragmentDataUpdate);\n\n      // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n\n    /**\n     * Render new data for the existing props/context.\n     */;\n    _proto._getConnectionData = function _getConnectionData() {\n      // Extract connection data and verify there are more edges to fetch\n      // eslint-disable-next-line no-unused-vars\n      var _this$props = this.props,\n        _ = _this$props.componentRef,\n        restProps = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, _excluded);\n      var props = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, restProps), this.state.data);\n      var connectionData = getConnectionFromProps(props);\n      if (connectionData == null) {\n        return null;\n      }\n      var _ConnectionInterface$2 = ConnectionInterface.get(),\n        EDGES = _ConnectionInterface$2.EDGES,\n        PAGE_INFO = _ConnectionInterface$2.PAGE_INFO,\n        HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE,\n        HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE,\n        END_CURSOR = _ConnectionInterface$2.END_CURSOR,\n        START_CURSOR = _ConnectionInterface$2.START_CURSOR;\n      !(typeof connectionData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : invariant(false) : void 0;\n      var edges = connectionData[EDGES];\n      var pageInfo = connectionData[PAGE_INFO];\n      if (edges == null || pageInfo == null) {\n        return null;\n      }\n      !Array.isArray(edges) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : invariant(false) : void 0;\n      !(typeof pageInfo === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : invariant(false) : void 0;\n      var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];\n      var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];\n      if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        return null;\n      }\n      return {\n        cursor: cursor,\n        edgeCount: edges.length,\n        hasMore: hasMore\n      };\n    };\n    _proto._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new ReactRelayQueryFetcher();\n      }\n      return this._queryFetcher;\n    };\n    _proto._canFetchPage = function _canFetchPage(method) {\n      if (this._isUnmounted) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayPaginationContainer: Unexpected call of `%s` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to fetch data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `%s` call.', method, containerName, method) : void 0;\n        return false;\n      }\n      return true;\n    };\n    _proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {\n      var _this3 = this;\n      var _assertRelayContext = assertRelayContext(this.props.__relayContext),\n        environment = _assertRelayContext.environment;\n      var _this$props2 = this.props,\n        _ = _this$props2.componentRef,\n        __relayContext = _this$props2.__relayContext,\n        __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer,\n        restProps = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props2, _excluded2);\n      var props = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, restProps), this.state.data);\n      var fragmentVariables;\n      var rootVariables = getRootVariablesForFragments(fragments, restProps);\n      fragmentVariables = getVariablesFromObject(fragments, restProps);\n      fragmentVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, rootVariables), fragmentVariables), this._refetchVariables);\n      var fetchVariables = connectionConfig.getVariables(props, {\n        count: paginatingVariables.count,\n        cursor: paginatingVariables.cursor\n      }, fragmentVariables);\n      !(typeof fetchVariables === 'object' && fetchVariables !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : invariant(false) : void 0;\n      fetchVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, fetchVariables), this._refetchVariables);\n      fragmentVariables = (0, _objectSpread3[\"default\"])((0, _objectSpread3[\"default\"])({}, fetchVariables), fragmentVariables);\n      var cacheConfig = options ? {\n        force: !!options.force\n      } : undefined;\n      if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {\n        cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;\n      }\n      var request = getRequest(connectionConfig.query);\n      var operation = createOperationDescriptor(request, fetchVariables, cacheConfig);\n      var refetchSubscription = null;\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n      }\n      this._hasFetched = true;\n      var onNext = function onNext(payload, complete) {\n        var prevData = _this3._resolver.resolve();\n        _this3._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);\n        var nextData = _this3._resolver.resolve();\n\n        // Workaround slightly different handling for connection in different\n        // core implementations:\n        // - Classic core requires the count to be explicitly incremented\n        // - Modern core automatically appends new items, updating the count\n        //   isn't required to see new data.\n        //\n        // `setState` is only required if changing the variables would change the\n        // resolved data.\n        // TODO #14894725: remove PaginationContainer equal check\n        if (!areEqual(prevData, nextData)) {\n          _this3.setState({\n            data: nextData,\n            contextForChildren: {\n              environment: _this3.props.__relayContext.environment\n            }\n          }, complete);\n        } else {\n          complete();\n        }\n      };\n      var cleanup = function cleanup() {\n        if (_this3._refetchSubscription === refetchSubscription) {\n          _this3._refetchSubscription = null;\n          _this3._isARequestInFlight = false;\n        }\n      };\n      this._isARequestInFlight = true;\n      refetchSubscription = this._getQueryFetcher().execute({\n        environment: environment,\n        operation: operation,\n        preservePreviousReferences: true\n      }).mergeMap(function (payload) {\n        return Observable.create(function (sink) {\n          onNext(payload, function () {\n            sink.next(); // pass void to public observer's `next`\n            sink.complete();\n          });\n        });\n      })\n      // use do instead of finally so that observer's `complete` fires after cleanup\n      [\"do\"]({\n        error: cleanup,\n        complete: cleanup,\n        unsubscribe: cleanup\n      }).subscribe(observer || {});\n      this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;\n      return refetchSubscription;\n    };\n    _proto._cleanup = function _cleanup() {\n      this._resolver.dispose();\n      this._refetchVariables = null;\n      this._hasFetched = false;\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n        this._refetchSubscription = null;\n        this._isARequestInFlight = false;\n      }\n      if (this._queryFetcher) {\n        this._queryFetcher.dispose();\n      }\n    }\n\n    // $FlowFixMe[missing-local-annot]\n    ;\n    _proto.render = function render() {\n      // eslint-disable-next-line no-unused-vars\n      var _this$props3 = this.props,\n        componentRef = _this$props3.componentRef,\n        __relayContext = _this$props3.__relayContext,\n        __rootIsQueryRenderer = _this$props3.__rootIsQueryRenderer,\n        props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props3, _excluded3);\n      return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n        value: this.state.contextForChildren\n      }, /*#__PURE__*/React.createElement(Component, (0, _extends2[\"default\"])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      })));\n    };\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _class;\n}\n\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\nfunction createContainer(Component, fragmentSpec, connectionConfig) {\n  // $FlowFixMe[incompatible-return]\n  return buildReactRelayContainer(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, connectionConfig);\n  });\n}\nmodule.exports = {\n  createContainer: createContainer\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar invariant = require('invariant');\nvar _require = require('relay-runtime'),\n  fetchQuery = _require.__internal.fetchQuery,\n  createOperationDescriptor = _require.createOperationDescriptor,\n  isRelayModernEnvironment = _require.isRelayModernEnvironment;\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_didFetchFinish\", false);\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n  var _proto = ReactRelayQueryFetcher.prototype;\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n        return environment.lookup(operation.fragment);\n      }\n    }\n    return null;\n  };\n  _proto.getFetchResult = function getFetchResult() {\n    if (this._didFetchFinish) {\n      // We don't reset '_didFetchFinish' because another callback may be set\n      if (this._error != null) {\n        return {\n          error: this._error\n        };\n      } else if (this._snapshot != null) {\n        return {\n          snapshot: this._snapshot\n        };\n      }\n    } else {\n      return null;\n    }\n  };\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n    var environment = _ref.environment,\n      operation = _ref.operation,\n      _ref$preservePrevious = _ref.preservePreviousReferences,\n      preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n    return fetchQuery(environment, operation)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n      if (this._didFetchFinish) {\n        // We don't reset '_didFetchFinish' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */;\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n    var environment = fetchOptions.environment,\n      operation = fetchOptions.operation,\n      onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n    var _error;\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      // $FlowFixMe[incompatible-use]\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n    var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;\n    var request = this.execute({\n      environment: environment,\n      operation: operationOverride\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._didFetchFinish = true;\n        _this2._error = null;\n\n        // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._didFetchFinish = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks;\n\n        // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n    if (_error) {\n      throw _error;\n    }\n    return this._snapshot;\n  };\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n    }, cacheConfigOverride);\n  };\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null;\n\n    // order is important, dispose of pendingFetch before selectionReferences\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n      this._rootSubscription = null;\n    }\n  };\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n    this._selectionReferences = [];\n  };\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n      environment = _this$_fetchOptions.environment,\n      onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n      operation = _this$_fetchOptions.operation;\n\n    // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n    if (this._snapshot) {\n      return;\n    }\n    this._snapshot = environment.lookup(operation.fragment);\n\n    // Subscribe to changes in the data of the root fragment\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n  return ReactRelayQueryFetcher;\n}();\nmodule.exports = ReactRelayQueryFetcher;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar ReactRelayContext = require('./ReactRelayContext');\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\nvar areEqual = require(\"fbjs/lib/areEqual\");\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  RelayFeatureFlags = _require.RelayFeatureFlags;\nvar _require2 = require('relay-runtime'),\n  createOperationDescriptor = _require2.createOperationDescriptor,\n  deepFreeze = _require2.deepFreeze,\n  getRequest = _require2.getRequest;\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n    _this = _React$Component.call(this, props) || this;\n\n    // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleDataChange\", function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n      _this.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        // Don't update state if nothing has changed.\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    });\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n    _this._maybeHiddenOrFastRefresh = false;\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      return resetQueryStateForUpdate(nextProps, prevState);\n    }\n    return null;\n  };\n  var _proto = ReactRelayQueryRenderer.prototype;\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n    if (this._maybeHiddenOrFastRefresh === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current cached resource will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, so that the query is re-evaluated\n      // (and potentially cause a refetch).\n      this._maybeHiddenOrFastRefresh = false;\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState(function (prevState) {\n        var newState = resetQueryStateForUpdate(_this2.props, prevState);\n        var requestCacheKey = newState.requestCacheKey,\n          queryFetcher = newState.queryFetcher;\n        if (requestCacheKey != null && requestCache[requestCacheKey] != null) {\n          if (RelayFeatureFlags.ENABLE_QUERY_RENDERER_SET_STATE_PREVENTION) {\n            var fetchResult = queryFetcher.getFetchResult();\n            if (fetchResult != null) {\n              var _fetchResult$snapshot, _fetchResult$error;\n              var snapshot = (_fetchResult$snapshot = fetchResult.snapshot) !== null && _fetchResult$snapshot !== void 0 ? _fetchResult$snapshot : null;\n              var error = (_fetchResult$error = fetchResult.error) !== null && _fetchResult$error !== void 0 ? _fetchResult$error : null;\n              var prevRequestCacheKey = prevState.requestCacheKey;\n              if (prevRequestCacheKey != null) {\n                delete requestCache[prevRequestCacheKey];\n              }\n              newState.renderProps = getRenderProps(error, snapshot, queryFetcher, prevState.retryCallbacks);\n              newState.snapshot = snapshot;\n              newState.requestCacheKey = null;\n            } else {\n              queryFetcher.setOnDataChange(_this2._handleDataChange);\n            }\n          } else {\n            queryFetcher.setOnDataChange(_this2._handleDataChange);\n          }\n        }\n        return newState;\n      });\n      return;\n    }\n    var _this$state = this.state,\n      retryCallbacks = _this$state.retryCallbacks,\n      queryFetcher = _this$state.queryFetcher,\n      requestCacheKey = _this$state.requestCacheKey;\n    // We don't need to cache the request after the component commits\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n    retryCallbacks.handleDataChange = this._handleDataChange;\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    };\n\n    // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n  _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {\n    // We don't need to cache the request after the component commits\n    var _this$state2 = this.state,\n      queryFetcher = _this$state2.queryFetcher,\n      requestCacheKey = _this$state2.requestCacheKey;\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n      // HACK\n      delete this.state.requestCacheKey;\n    }\n    if (this.props.query && queryFetcher !== prevState.queryFetcher) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n    this._maybeHiddenOrFastRefresh = true;\n  };\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n  _proto.render = function render() {\n    var _this$state3 = this.state,\n      renderProps = _this$state3.renderProps,\n      relayContext = _this$state3.relayContext;\n    // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n  return ReactRelayQueryRenderer;\n}(React.Component);\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\nfunction resetQueryStateForUpdate(props, prevState) {\n  var query = props.query;\n  var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n  prevState.queryFetcher.disposeRequest();\n  var queryFetcher;\n  if (query) {\n    var request = getRequest(query);\n    var requestCacheKey = getRequestCacheKey(request.params, props.variables);\n    queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n  } else {\n    queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n  }\n  return (0, _objectSpread2[\"default\"])({\n    prevQuery: props.query,\n    prevPropsEnvironment: props.environment,\n    prevPropsVariables: props.variables,\n    queryFetcher: queryFetcher\n  }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks\n  // passing no requestCacheKey will cause it to be recalculated internally\n  // and we want the updated requestCacheKey, since variables may have changed\n  ));\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n    query = props.query,\n    variables = props.variables,\n    cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n\n      var snapshot = requestCache[requestCacheKey].snapshot;\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: null,\n        operation: operation\n      });\n\n      // Use network data first, since it may be fresher\n      var _snapshot = querySnapshot || storeSnapshot;\n\n      // cache the request to avoid duplicate requests\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar React = require('react');\nmodule.exports = React.createContext({\n  rootIsQueryRenderer: false\n});","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _excluded = [\"componentRef\", \"__relayContext\", \"__rootIsQueryRenderer\"];\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\nvar getRootVariablesForFragments = require('./getRootVariablesForFragments');\nvar _require = require('./ReactRelayContainerUtils'),\n  getContainerName = _require.getContainerName;\nvar ReactRelayContext = require('./ReactRelayContext');\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\nvar _require2 = require('./RelayContext'),\n  assertRelayContext = _require2.assertRelayContext;\nvar areEqual = require(\"fbjs/lib/areEqual\");\nvar React = require('react');\nvar _require3 = require('relay-runtime'),\n  Observable = _require3.Observable,\n  createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n  createOperationDescriptor = _require3.createOperationDescriptor,\n  getDataIDsFromObject = _require3.getDataIDsFromObject,\n  getRequest = _require3.getRequest,\n  getVariablesFromObject = _require3.getVariablesFromObject,\n  isScalarAndEqual = _require3.isScalarAndEqual;\nvar warning = require(\"fbjs/lib/warning\");\n/**\n * Composes a React component class, returning a new class that intercepts\n * props, resolving them with the provided fragments and subscribing for\n * updates.\n */\nfunction createContainerWithFragments(Component, fragments, taggedNode) {\n  var _class;\n  var containerName = getContainerName(Component);\n  return _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n    // $FlowFixMe[missing-local-annot]\n\n    function _class(props) {\n      var _props$__rootIsQueryR, _this;\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        var resolverFromThisUpdate = _this.state.resolver;\n        _this.setState(function (updatedState) {\n          return (\n            // If this event belongs to the current data source, update.\n            // Otherwise we should ignore it.\n            resolverFromThisUpdate === updatedState.resolver ? {\n              data: updatedState.resolver.resolve()\n            } : null\n          );\n        });\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_refetch\", function (refetchVariables, renderVariables, observerOrCallback, options) {\n        if (_this._isUnmounted) {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayRefetchContainer: Unexpected call of `refetch` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to refetch the data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `refetch`.', containerName) : void 0;\n          return {\n            dispose: function dispose() {}\n          };\n        }\n        var _assertRelayContext = assertRelayContext(_this.props.__relayContext),\n          environment = _assertRelayContext.environment;\n        var rootVariables = getRootVariablesForFragments(fragments, _this.props);\n        var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;\n        fetchVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, rootVariables), fetchVariables);\n        var fragmentVariables = renderVariables ? (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, fetchVariables), renderVariables) : fetchVariables;\n        var cacheConfig = options ? {\n          force: !!options.force\n        } : undefined;\n        if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {\n          cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;\n        }\n        var observer = typeof observerOrCallback === 'function' ? {\n          // callback is not exectued on complete or unsubscribe\n          // for backward compatibility\n          next: observerOrCallback,\n          error: observerOrCallback\n        } : observerOrCallback || {};\n        var query = getRequest(taggedNode);\n        var operation = createOperationDescriptor(query, fetchVariables, cacheConfig);\n\n        // TODO: T26288752 find a better way\n        _this.state.localVariables = fetchVariables;\n\n        // Cancel any previously running refetch.\n        _this._refetchSubscription && _this._refetchSubscription.unsubscribe();\n\n        // Declare refetchSubscription before assigning it in .start(), since\n        // synchronous completion may call callbacks .subscribe() returns.\n        var refetchSubscription;\n        var storeSnapshot = _this._getQueryFetcher().lookupInStore(environment, operation, options === null || options === void 0 ? void 0 : options.fetchPolicy);\n        if (storeSnapshot != null) {\n          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);\n          _this.setState(function (latestState) {\n            return {\n              data: latestState.resolver.resolve(),\n              contextForChildren: {\n                environment: _this.props.__relayContext.environment\n              }\n            };\n          }, function () {\n            observer.next && observer.next();\n            observer.complete && observer.complete();\n          });\n          return {\n            dispose: function dispose() {}\n          };\n        }\n        _this._getQueryFetcher().execute({\n          environment: environment,\n          operation: operation,\n          // TODO (T26430099): Cleanup old references\n          preservePreviousReferences: true\n        }).mergeMap(function (response) {\n          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);\n          return Observable.create(function (sink) {\n            return _this.setState(function (latestState) {\n              return {\n                data: latestState.resolver.resolve(),\n                contextForChildren: {\n                  environment: _this.props.__relayContext.environment\n                }\n              };\n            }, function () {\n              sink.next();\n              sink.complete();\n            });\n          });\n        })[\"finally\"](function () {\n          // Finalizing a refetch should only clear this._refetchSubscription\n          // if the finizing subscription is the most recent call.\n          if (_this._refetchSubscription === refetchSubscription) {\n            _this._refetchSubscription = null;\n          }\n        }).subscribe((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n          start: function start(subscription) {\n            _this._refetchSubscription = refetchSubscription = subscription;\n            observer.start && observer.start(subscription);\n          }\n        }));\n        return {\n          dispose: function dispose() {\n            refetchSubscription && refetchSubscription.unsubscribe();\n          }\n        };\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;\n      _this._refetchSubscription = null;\n      // Do not provide a subscription/callback here.\n      // It is possible for this render to be interrupted or aborted,\n      // In which case the subscription would cause a leak.\n      // We will add the subscription in componentDidMount().\n      var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);\n      _this.state = {\n        data: resolver.resolve(),\n        localVariables: null,\n        prevProps: props,\n        prevPropsContext: relayContext,\n        contextForChildren: relayContext,\n        relayProp: getRelayProp(relayContext.environment, _this._refetch),\n        resolver: resolver\n      };\n      _this._isUnmounted = false;\n      return _this;\n    }\n    var _proto = _class.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n      this._isUnmounted = false;\n      this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (this.state.resolver !== prevState.resolver) {\n        prevState.resolver.dispose();\n        this._queryFetcher && this._queryFetcher.dispose();\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n        this._subscribeToNewResolverAndRerenderIfStoreHasChanged();\n      } else {\n        this._rerenderIfStoreHasChanged();\n      }\n    }\n\n    /**\n     * When new props are received, read data for the new props and add it to\n     * state. Props may be the same in which case previous data can be reused.\n     */;\n    _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      var _nextProps$__rootIsQu;\n      // Any props change could impact the query, so we mirror props in state.\n      // This is an unusual pattern, but necessary for this container usecase.\n      var prevProps = prevState.prevProps;\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;\n      var prevIDs = getDataIDsFromObject(fragments, prevProps);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var prevRootVariables = getRootVariablesForFragments(fragments, prevProps);\n      var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);\n      var resolver = prevState.resolver;\n\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {\n        // Do not provide a subscription/callback here.\n        // It is possible for this render to be interrupted or aborted,\n        // In which case the subscription would cause a leak.\n        // We will add the subscription in componentDidUpdate().\n        resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);\n        return {\n          data: resolver.resolve(),\n          localVariables: null,\n          prevProps: nextProps,\n          prevPropsContext: relayContext,\n          contextForChildren: relayContext,\n          relayProp: getRelayProp(relayContext.environment, prevState.relayProp.refetch),\n          resolver: resolver\n        };\n      } else if (!prevState.localVariables) {\n        resolver.setProps(nextProps);\n      }\n      var data = resolver.resolve();\n      if (data !== prevState.data) {\n        return {\n          data: data,\n          prevProps: nextProps\n        };\n      }\n      return null;\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._isUnmounted = true;\n      this.state.resolver.dispose();\n      this._queryFetcher && this._queryFetcher.dispose();\n      this._refetchSubscription && this._refetchSubscription.unsubscribe();\n    };\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {\n        return true;\n      }\n      // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n      var keys = Object.keys(nextProps);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        if (key === '__relayContext') {\n          if (this.state.prevPropsContext.environment !== nextState.prevPropsContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {\n      var _this$state = this.state,\n        data = _this$state.data,\n        resolver = _this$state.resolver;\n      // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n      var maybeNewData = resolver.resolve();\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n    _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {\n      var _this$state2 = this.state,\n        data = _this$state2.data,\n        resolver = _this$state2.resolver;\n      var maybeNewData = resolver.resolve();\n\n      // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n      resolver.setCallback(this.props, this._handleFragmentDataUpdate);\n\n      // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n\n    /**\n     * Render new data for the existing props/context.\n     */;\n    _proto._getFragmentVariables = function _getFragmentVariables() {\n      return getVariablesFromObject(fragments, this.props);\n    };\n    _proto._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new ReactRelayQueryFetcher();\n      }\n      return this._queryFetcher;\n    };\n    // $FlowFixMe[missing-local-annot]\n    _proto.render = function render() {\n      // eslint-disable-next-line no-unused-vars\n      var _this$props = this.props,\n        componentRef = _this$props.componentRef,\n        __relayContext = _this$props.__relayContext,\n        __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer,\n        props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, _excluded);\n      var _this$state3 = this.state,\n        relayProp = _this$state3.relayProp,\n        contextForChildren = _this$state3.contextForChildren;\n      return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n        value: contextForChildren\n      }, /*#__PURE__*/React.createElement(Component, (0, _extends2[\"default\"])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: relayProp\n      })));\n    };\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _class;\n}\nfunction getRelayProp(environment, refetch) {\n  return {\n    environment: environment,\n    refetch: refetch\n  };\n}\n\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\nfunction createContainer(Component, fragmentSpec, taggedNode) {\n  // $FlowFixMe[incompatible-return]\n  return buildReactRelayContainer(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, taggedNode);\n  });\n}\nmodule.exports = {\n  createContainer: createContainer\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar isRelayEnvironment = require('./isRelayEnvironment');\nvar invariant = require('invariant');\n\n/**\n * Asserts that the input is a matches the `RelayContext` type defined in\n * `RelayEnvironmentTypes` and returns it as that type.\n */\nfunction assertRelayContext(relay) {\n  !isRelayContext(relay) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayContext: Expected `context.relay` to be an object conforming to ' + 'the `RelayContext` interface, got `%s`.', relay) : invariant(false) : void 0;\n  return relay;\n}\n\n/**\n * Determine if the input is a plain object that matches the `RelayContext`\n * type defined in `RelayEnvironmentTypes`.\n */\nfunction isRelayContext(context) {\n  return typeof context === 'object' && context !== null && !Array.isArray(context) && isRelayEnvironment(context.environment);\n}\nmodule.exports = {\n  assertRelayContext: assertRelayContext,\n  isRelayContext: isRelayContext\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar invariant = require('invariant');\n\n/**\n * Fail fast if the user supplies invalid fragments as input.\n */\nfunction assertFragmentMap(componentName, fragmentSpec) {\n  !(fragmentSpec && typeof fragmentSpec === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not create Relay Container for `%s`. ' + 'Expected a set of GraphQL fragments, got `%s` instead.', componentName, fragmentSpec) : invariant(false) : void 0;\n  for (var key in fragmentSpec) {\n    if (fragmentSpec.hasOwnProperty(key)) {\n      var fragment = fragmentSpec[key];\n      !(fragment && (typeof fragment === 'object' || typeof fragment === 'function')) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not create Relay Container for `%s`. ' + 'The value of fragment `%s` was expected to be a fragment, got `%s` instead.', componentName, key, fragment) : invariant(false) : void 0;\n    }\n  }\n}\nmodule.exports = assertFragmentMap;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar assertFragmentMap = require('./assertFragmentMap');\nvar _require = require('./ReactRelayContainerUtils'),\n  getComponentName = _require.getComponentName,\n  getContainerName = _require.getContainerName;\nvar ReactRelayContext = require('./ReactRelayContext');\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\nvar invariant = require('invariant');\nvar React = require('react');\nvar _require2 = require('relay-runtime'),\n  getFragment = _require2.getFragment;\nvar useContext = React.useContext;\n/**\n * Helper to create the Relay HOCs with ref forwarding, setting the displayName\n * and reading the React context.\n */\nfunction buildReactRelayContainer(ComponentClass, fragmentSpec, createContainerWithFragments) {\n  // Sanity-check user-defined fragment input\n  var containerName = getContainerName(ComponentClass);\n  assertFragmentMap(getComponentName(ComponentClass), fragmentSpec);\n  var fragments = {};\n  for (var key in fragmentSpec) {\n    fragments[key] = getFragment(fragmentSpec[key]);\n  }\n  var Container = createContainerWithFragments(ComponentClass, fragments);\n  Container.displayName = containerName;\n  function forwardRef(props, ref) {\n    var _queryRendererContext;\n    var context = useContext(ReactRelayContext);\n    !(context != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`%s` tried to render a context that was not valid this means that ' + '`%s` was rendered outside of a query renderer.', containerName, containerName) : invariant(false) : void 0;\n    var queryRendererContext = useContext(ReactRelayQueryRendererContext);\n    return /*#__PURE__*/React.createElement(Container, (0, _extends2[\"default\"])({}, props, {\n      __relayContext: context,\n      __rootIsQueryRenderer: (_queryRendererContext = queryRendererContext === null || queryRendererContext === void 0 ? void 0 : queryRendererContext.rootIsQueryRenderer) !== null && _queryRendererContext !== void 0 ? _queryRendererContext : false,\n      componentRef: props.componentRef || ref\n    }));\n  }\n  forwardRef.displayName = containerName;\n  var ForwardContainer = React.forwardRef(forwardRef);\n  if (process.env.NODE_ENV !== \"production\") {\n    // Used by RelayModernTestUtils\n    ForwardContainer.__ComponentClass = ComponentClass;\n    ForwardContainer.displayName = containerName;\n  }\n\n  // $FlowFixMe[incompatible-return]\n  return ForwardContainer;\n}\nmodule.exports = buildReactRelayContainer;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _require = require('relay-runtime'),\n  getSelector = _require.getSelector;\nfunction getRootVariablesForFragments(fragments, props) {\n  var rootVariables = {};\n  // NOTE: For extra safety, we make sure the rootVariables include the\n  // variables from all owners in this fragmentSpec, even though they\n  // should all point to the same owner\n  Object.keys(fragments).forEach(function (key) {\n    var _selector$selectors$, _selector$selectors$2, _selector$owner$varia;\n    var fragmentNode = fragments[key];\n    var fragmentRef = props[key];\n    var selector = getSelector(fragmentNode, fragmentRef);\n    var fragmentOwnerVariables = selector != null && selector.kind === 'PluralReaderSelector' ? (_selector$selectors$ = (_selector$selectors$2 = selector.selectors[0]) === null || _selector$selectors$2 === void 0 ? void 0 : _selector$selectors$2.owner.variables) !== null && _selector$selectors$ !== void 0 ? _selector$selectors$ : {} : (_selector$owner$varia = selector === null || selector === void 0 ? void 0 : selector.owner.variables) !== null && _selector$owner$varia !== void 0 ? _selector$owner$varia : {};\n    rootVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, rootVariables), fragmentOwnerVariables);\n  });\n  return rootVariables;\n}\nmodule.exports = getRootVariablesForFragments;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar ReactRelayContext = require('./ReactRelayContext');\nvar ReactRelayFragmentContainer = require('./ReactRelayFragmentContainer');\nvar ReactRelayLocalQueryRenderer = require('./ReactRelayLocalQueryRenderer');\nvar ReactRelayPaginationContainer = require('./ReactRelayPaginationContainer');\nvar ReactRelayQueryRenderer = require('./ReactRelayQueryRenderer');\nvar ReactRelayRefetchContainer = require('./ReactRelayRefetchContainer');\nvar EntryPointContainer = require('./relay-hooks/EntryPointContainer.react');\nvar loadEntryPoint = require('./relay-hooks/loadEntryPoint');\nvar _require = require('./relay-hooks/loadQuery'),\n  loadQuery = _require.loadQuery;\nvar ProfilerContext = require('./relay-hooks/ProfilerContext');\nvar RelayEnvironmentProvider = require('./relay-hooks/RelayEnvironmentProvider');\nvar useClientQuery = require('./relay-hooks/useClientQuery');\nvar useEntryPointLoader = require('./relay-hooks/useEntryPointLoader');\nvar useFragment = require('./relay-hooks/useFragment');\nvar useLazyLoadQuery = require('./relay-hooks/useLazyLoadQuery');\nvar useMutation = require('./relay-hooks/useMutation');\nvar usePaginationFragment = require('./relay-hooks/usePaginationFragment');\nvar usePreloadedQuery = require('./relay-hooks/usePreloadedQuery');\nvar useQueryLoader = require('./relay-hooks/useQueryLoader');\nvar useRefetchableFragment = require('./relay-hooks/useRefetchableFragment');\nvar useRelayEnvironment = require('./relay-hooks/useRelayEnvironment');\nvar useSubscribeToInvalidationState = require('./relay-hooks/useSubscribeToInvalidationState');\nvar useSubscription = require('./relay-hooks/useSubscription');\nvar RelayRuntime = require('relay-runtime');\n/**\n * The public interface to react-relay.\n * Currently contains both Relay Hooks and legacy Container APIs.\n * Will eventually only export the interface from ./hooks.js.\n */\nmodule.exports = {\n  ConnectionHandler: RelayRuntime.ConnectionHandler,\n  QueryRenderer: ReactRelayQueryRenderer,\n  LocalQueryRenderer: ReactRelayLocalQueryRenderer,\n  MutationTypes: RelayRuntime.MutationTypes,\n  RangeOperations: RelayRuntime.RangeOperations,\n  ReactRelayContext: ReactRelayContext,\n  applyOptimisticMutation: RelayRuntime.applyOptimisticMutation,\n  commitLocalUpdate: RelayRuntime.commitLocalUpdate,\n  commitMutation: RelayRuntime.commitMutation,\n  createFragmentContainer: ReactRelayFragmentContainer.createContainer,\n  createPaginationContainer: ReactRelayPaginationContainer.createContainer,\n  createRefetchContainer: ReactRelayRefetchContainer.createContainer,\n  fetchQuery_DEPRECATED: RelayRuntime.fetchQuery_DEPRECATED,\n  graphql: RelayRuntime.graphql,\n  readInlineData: RelayRuntime.readInlineData,\n  requestSubscription: RelayRuntime.requestSubscription,\n  // Relay Hooks\n  EntryPointContainer: EntryPointContainer,\n  RelayEnvironmentProvider: RelayEnvironmentProvider,\n  ProfilerContext: ProfilerContext,\n  fetchQuery: RelayRuntime.fetchQuery,\n  loadQuery: loadQuery,\n  loadEntryPoint: loadEntryPoint,\n  useClientQuery: useClientQuery,\n  useFragment: useFragment,\n  useLazyLoadQuery: useLazyLoadQuery,\n  useEntryPointLoader: useEntryPointLoader,\n  useQueryLoader: useQueryLoader,\n  useMutation: useMutation,\n  usePaginationFragment: usePaginationFragment,\n  usePreloadedQuery: usePreloadedQuery,\n  useRefetchableFragment: useRefetchableFragment,\n  useRelayEnvironment: useRelayEnvironment,\n  useSubscribeToInvalidationState: useSubscribeToInvalidationState,\n  useSubscription: useSubscription\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\n/**\n * Determine if a given value is an object that implements the `Environment`\n * interface defined in `RelayEnvironmentTypes`.\n */\nfunction isRelayEnvironment(environment) {\n  return typeof environment === 'object' && environment !== null &&\n  // TODO: add applyMutation/sendMutation once ready in both cores\n  typeof environment.check === 'function' && typeof environment.lookup === 'function' && typeof environment.retain === 'function' && typeof environment.execute === 'function' && typeof environment.subscribe === 'function';\n}\nmodule.exports = isRelayEnvironment;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar ProfilerContext = require('./ProfilerContext');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar React = require('react');\nvar _require = require('react'),\n  useContext = _require.useContext,\n  useEffect = _require.useEffect;\nvar warning = require(\"fbjs/lib/warning\");\nfunction EntryPointContainer(_ref) {\n  var entryPointReference = _ref.entryPointReference,\n    props = _ref.props;\n  process.env.NODE_ENV !== \"production\" ? warning(entryPointReference.isDisposed === false, '<EntryPointContainer>: Expected entryPointReference to not be disposed ' + 'yet. This is because disposing the entrypoint marks it for future garbage ' + 'collection, and as such may no longer be present in the Relay store. ' + 'In the future, this will become a hard error.') : void 0;\n  var getComponent = entryPointReference.getComponent,\n    queries = entryPointReference.queries,\n    entryPoints = entryPointReference.entryPoints,\n    extraProps = entryPointReference.extraProps,\n    rootModuleID = entryPointReference.rootModuleID;\n  var Component = getComponent();\n  var profilerContext = useContext(ProfilerContext);\n  var environment = useRelayEnvironment();\n  useEffect(function () {\n    environment.__log({\n      name: 'entrypoint.root.consume',\n      profilerContext: profilerContext,\n      rootModuleID: rootModuleID\n    });\n  }, [environment, profilerContext, rootModuleID]);\n  return /*#__PURE__*/React.createElement(Component, {\n    entryPoints: entryPoints,\n    extraProps: extraProps,\n    props: props,\n    queries: queries\n  });\n}\nmodule.exports = EntryPointContainer;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar LRUCache = require('./LRUCache');\nvar _require = require('./QueryResource'),\n  getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;\nvar SuspenseResource = require('./SuspenseResource');\nvar invariant = require('invariant');\nvar _require2 = require('relay-runtime'),\n  _require2$__internal = _require2.__internal,\n  fetchQuery = _require2$__internal.fetchQuery,\n  getPromiseForActiveRequest = _require2$__internal.getPromiseForActiveRequest,\n  RelayFeatureFlags = _require2.RelayFeatureFlags,\n  createOperationDescriptor = _require2.createOperationDescriptor,\n  getFragmentIdentifier = _require2.getFragmentIdentifier,\n  getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,\n  getSelector = _require2.getSelector,\n  getVariablesFromFragment = _require2.getVariablesFromFragment,\n  handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors,\n  isPromise = _require2.isPromise,\n  recycleNodesInto = _require2.recycleNodesInto;\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\nvar CACHE_CAPACITY = 1000000;\n\n// this is frozen so that users don't accidentally push data into the array\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n  return snapshot.isMissingData;\n}\nfunction hasMissingClientEdges(snapshot) {\n  var _snapshot$missingClie, _snapshot$missingClie2;\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      var _s$missingClientEdges, _s$missingClientEdges2;\n      return ((_s$missingClientEdges = (_s$missingClientEdges2 = s.missingClientEdges) === null || _s$missingClientEdges2 === void 0 ? void 0 : _s$missingClientEdges2.length) !== null && _s$missingClientEdges !== void 0 ? _s$missingClientEdges : 0) > 0;\n    });\n  }\n  return ((_snapshot$missingClie = (_snapshot$missingClie2 = snapshot.missingClientEdges) === null || _snapshot$missingClie2 === void 0 ? void 0 : _snapshot$missingClie2.length) !== null && _snapshot$missingClie !== void 0 ? _snapshot$missingClie : 0) > 0;\n}\nfunction missingLiveResolverFields(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.map(function (s) {\n      return s.missingLiveResolverFields;\n    }).filter(Boolean).flat();\n  }\n  return snapshot.missingLiveResolverFields;\n}\nfunction singularOrPluralForEach(snapshot, f) {\n  if (Array.isArray(snapshot)) {\n    snapshot.forEach(f);\n  } else {\n    f(snapshot);\n  }\n}\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n\n/**\n * The purpose of this cache is to allow information to be passed from an\n * initial read which suspends through to the commit that follows a subsequent\n * successful read. Specifically, the QueryResource result for the data fetch\n * is passed through so that that query can be retained on commit.\n */\nvar ClientEdgeQueryResultsCache = /*#__PURE__*/function () {\n  function ClientEdgeQueryResultsCache(environment) {\n    (0, _defineProperty2[\"default\"])(this, \"_cache\", new Map());\n    (0, _defineProperty2[\"default\"])(this, \"_retainCounts\", new Map());\n    this._environment = environment;\n  }\n  var _proto = ClientEdgeQueryResultsCache.prototype;\n  _proto.get = function get(fragmentIdentifier) {\n    var _this$_cache$get$, _this$_cache$get;\n    return (_this$_cache$get$ = (_this$_cache$get = this._cache.get(fragmentIdentifier)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get[0]) !== null && _this$_cache$get$ !== void 0 ? _this$_cache$get$ : undefined;\n  };\n  _proto.recordQueryResults = function recordQueryResults(fragmentIdentifier, value // may be mutated after being passed here\n  ) {\n    var _this = this;\n    var existing = this._cache.get(fragmentIdentifier);\n    if (!existing) {\n      var suspenseResource = new SuspenseResource(function () {\n        return _this._retain(fragmentIdentifier);\n      });\n      this._cache.set(fragmentIdentifier, [value, suspenseResource]);\n      suspenseResource.temporaryRetain(this._environment);\n    } else {\n      var existingResults = existing[0],\n        _suspenseResource = existing[1];\n      value.forEach(function (queryResult) {\n        existingResults.push(queryResult);\n      });\n      _suspenseResource.temporaryRetain(this._environment);\n    }\n  };\n  _proto._retain = function _retain(id) {\n    var _this2 = this;\n    var _this$_retainCounts$g;\n    var retainCount = ((_this$_retainCounts$g = this._retainCounts.get(id)) !== null && _this$_retainCounts$g !== void 0 ? _this$_retainCounts$g : 0) + 1;\n    this._retainCounts.set(id, retainCount);\n    return {\n      dispose: function dispose() {\n        var _this$_retainCounts$g2;\n        var newRetainCount = ((_this$_retainCounts$g2 = _this2._retainCounts.get(id)) !== null && _this$_retainCounts$g2 !== void 0 ? _this$_retainCounts$g2 : 0) - 1;\n        if (newRetainCount > 0) {\n          _this2._retainCounts.set(id, newRetainCount);\n        } else {\n          _this2._retainCounts[\"delete\"](id);\n          _this2._cache[\"delete\"](id);\n        }\n      }\n    };\n  };\n  return ClientEdgeQueryResultsCache;\n}();\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      this._clientEdgeQueryResultsCache = new ClientEdgeQueryResultsCache(environment);\n    }\n  }\n\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n  var _proto2 = FragmentResourceImpl.prototype;\n  _proto2.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */;\n  _proto2.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _this3 = this;\n    var _fragmentNode$metadat, _fragmentNode$metadat2, _missingLiveResolverF2, _missingLiveResolverF3;\n    var environment = this._environment;\n\n    // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n    var storeEpoch = environment.getStore().getEpoch();\n\n    // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    }\n\n    // Now we actually attempt to read the fragment:\n\n    // 1. Check if there's a cached value for this fragment\n    var cachedValue = this._cache.get(fragmentIdentifier);\n    if (cachedValue != null) {\n      var _missingLiveResolverF;\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n        throw cachedValue.promise;\n      }\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot && !((_missingLiveResolverF = missingLiveResolverFields(cachedValue.result.snapshot)) !== null && _missingLiveResolverF !== void 0 && _missingLiveResolverF.length)) {\n        this._throwOrLogErrorsInSnapshot(\n        // $FlowFixMe[incompatible-call]\n        cachedValue.result.snapshot);\n\n        // This cache gets populated directly whenever the store notifies us of\n        // an update. That mechanism does not check for missing data, or\n        // in-flight requests.\n        if (cachedValue.result.isMissingData) {\n          environment.__log({\n            name: 'fragmentresource.missing_data',\n            data: cachedValue.result.data,\n            fragment: fragmentNode,\n            isRelayHooks: true,\n            cached: true\n          });\n        }\n        return cachedValue.result;\n      }\n    }\n\n    // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n    if (!fragmentResult.isMissingData) {\n      this._throwOrLogErrorsInSnapshot(snapshot);\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n      return fragmentResult;\n    }\n\n    // 3. If we don't have data in the store, there's two cases where we should\n    // suspend to await the data: First if any client edges were traversed where\n    // the destination record was missing data; in that case we initiate a query\n    // here to fetch the missing data. Second, there may already be a request\n    // in flight for the fragment's parent query, or for another operation that\n    //  may affect the parent's query data, such as a mutation or subscription.\n    // For any of these cases we can get a promise, which we will cache and\n    // suspend on.\n\n    // First, initiate a query for any client edges that were missing data:\n    var clientEdgeRequests = null;\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true && hasMissingClientEdges(snapshot)) {\n      clientEdgeRequests = [];\n      var queryResource = getQueryResourceForEnvironment(this._environment);\n      var queryResults = [];\n      singularOrPluralForEach(snapshot, function (snap) {\n        var _snap$missingClientEd;\n        (_snap$missingClientEd = snap.missingClientEdges) === null || _snap$missingClientEd === void 0 ? void 0 : _snap$missingClientEd.forEach(function (_ref) {\n          var _clientEdgeRequests;\n          var request = _ref.request,\n            clientEdgeDestinationID = _ref.clientEdgeDestinationID;\n          var _this3$_performClient = _this3._performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID),\n            queryResult = _this3$_performClient.queryResult,\n            requestDescriptor = _this3$_performClient.requestDescriptor;\n          queryResults.push(queryResult);\n          (_clientEdgeRequests = clientEdgeRequests) === null || _clientEdgeRequests === void 0 ? void 0 : _clientEdgeRequests.push(requestDescriptor);\n        });\n      });\n      // Store the query so that it can be retained when our own fragment is\n      // subscribed to. This merges with any existing query results:\n      !(this._clientEdgeQueryResultsCache != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client edge query result cache should exist when ENABLE_CLIENT_EDGES is on.') : invariant(false) : void 0;\n      this._clientEdgeQueryResultsCache.recordQueryResults(fragmentIdentifier, queryResults);\n    }\n    var clientEdgePromises = [];\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && clientEdgeRequests) {\n      clientEdgePromises = clientEdgeRequests.map(function (request) {\n        return getPromiseForActiveRequest(_this3._environment, request);\n      }).filter(Boolean);\n    }\n\n    // Finally look for operations in flight for our parent query:\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n    var parentQueryPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n    var parentQueryPromiseResultPromise = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.promise; // for refinement\n    var missingResolverFieldPromises = (_missingLiveResolverF2 = (_missingLiveResolverF3 = missingLiveResolverFields(snapshot)) === null || _missingLiveResolverF3 === void 0 ? void 0 : _missingLiveResolverF3.map(function (_ref2) {\n      var liveStateID = _ref2.liveStateID;\n      var store = environment.getStore();\n\n      // $FlowFixMe[prop-missing] This is expected to be a LiveResolverStore\n      return store.getLiveResolverPromise(liveStateID);\n    })) !== null && _missingLiveResolverF2 !== void 0 ? _missingLiveResolverF2 : [];\n    if (clientEdgePromises.length || missingResolverFieldPromises.length || isPromise(parentQueryPromiseResultPromise)) {\n      var _parentQueryPromiseRe, _clientEdgeRequests2;\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        // TODO! Attach information here about missing live resolver fields\n        pendingOperations: [].concat((0, _toConsumableArray2[\"default\"])((_parentQueryPromiseRe = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.pendingOperations) !== null && _parentQueryPromiseRe !== void 0 ? _parentQueryPromiseRe : []), (0, _toConsumableArray2[\"default\"])((_clientEdgeRequests2 = clientEdgeRequests) !== null && _clientEdgeRequests2 !== void 0 ? _clientEdgeRequests2 : []))\n      });\n      var promises = [];\n      if (clientEdgePromises.length > 0) {\n        promises = promises.concat(clientEdgePromises);\n      }\n      if (missingResolverFieldPromises.length > 0) {\n        promises = promises.concat(missingResolverFieldPromises);\n      }\n      if (promises.length > 0) {\n        if (parentQueryPromiseResultPromise) {\n          promises.push(parentQueryPromiseResultPromise);\n        }\n        throw Promise.all(promises);\n      }\n\n      // Note: we are re-throwing the `parentQueryPromiseResultPromise` here,\n      // because some of our suspense-related code is relying on the instance equality\n      // of thrown promises. See FragmentResource-test.js\n      if (parentQueryPromiseResultPromise) {\n        throw parentQueryPromiseResultPromise;\n      }\n    }\n    this._throwOrLogErrorsInSnapshot(snapshot);\n\n    // At this point, there's nothing we can do. We don't have all the expected\n    // data, but there's no indication the missing data will be fulfilled. So we\n    // choose to return potentially non-typesafe data. The data returned here\n    // might not match the generated types for this fragment/operation.\n    environment.__log({\n      name: 'fragmentresource.missing_data',\n      data: fragmentResult.data,\n      fragment: fragmentNode,\n      isRelayHooks: true,\n      cached: false\n    });\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n  _proto2._performClientEdgeQuery = function _performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID) {\n    var originalVariables = getVariablesFromFragment(fragmentNode, fragmentRef);\n    var variables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, originalVariables), {}, {\n      id: clientEdgeDestinationID // TODO should be a reserved name\n    });\n\n    var operation = createOperationDescriptor(request, variables, {} //  TODO cacheConfig should probably inherent from parent operation\n    );\n\n    var fetchObservable = fetchQuery(this._environment, operation);\n    var queryResult = queryResource.prepare(operation, fetchObservable\n    // TODO should inherent render policy etc. from parent operation\n    );\n\n    return {\n      requestDescriptor: operation.request,\n      queryResult: queryResult\n    };\n  };\n  _proto2._throwOrLogErrorsInSnapshot = function _throwOrLogErrorsInSnapshot(snapshot) {\n    var _this4 = this;\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        handlePotentialSnapshotErrors(_this4._environment, s.missingRequiredFields, s.relayResolverErrors);\n      });\n    } else {\n      handlePotentialSnapshotErrors(this._environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors);\n    }\n  };\n  _proto2.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n    for (var key in fragmentNodes) {\n      result[key] = this.read(fragmentNodes[key], fragmentRefs[key], componentDisplayName, key);\n    }\n    return result;\n  };\n  _proto2.subscribe = function subscribe(fragmentResult, callback) {\n    var _this5 = this;\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    }\n\n    // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n      didMissUpdates = _this$checkMissedUpda[0],\n      currentSnapshot = _this$checkMissedUpda[1];\n\n    // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n    if (didMissUpdates) {\n      callback();\n    }\n\n    // 3. Establish subscriptions on the snapshot(s)\n    var disposables = [];\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        disposables.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n          _this5._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      disposables.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n        _this5._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n        callback();\n      }));\n    }\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      var _this$_clientEdgeQuer, _this$_clientEdgeQuer2;\n      var clientEdgeQueryResults = (_this$_clientEdgeQuer = (_this$_clientEdgeQuer2 = this._clientEdgeQueryResultsCache) === null || _this$_clientEdgeQuer2 === void 0 ? void 0 : _this$_clientEdgeQuer2.get(cacheKey)) !== null && _this$_clientEdgeQuer !== void 0 ? _this$_clientEdgeQuer : undefined;\n      if (clientEdgeQueryResults !== null && clientEdgeQueryResults !== void 0 && clientEdgeQueryResults.length) {\n        var queryResource = getQueryResourceForEnvironment(this._environment);\n        clientEdgeQueryResults.forEach(function (queryResult) {\n          disposables.push(queryResource.retain(queryResult));\n        });\n      }\n    }\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (s) {\n          return s.dispose();\n        });\n        _this5._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n  _proto2.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this6 = this;\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this6.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n  _proto2.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n    var storeEpoch = null;\n    // Bail out if the store hasn't been written since last read\n    storeEpoch = environment.getStore().getEpoch();\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n    var cacheKey = fragmentResult.cacheKey;\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n        currentSnapshots[idx] = currentSnapshot;\n      });\n      // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n      return [didMissUpdates, currentSnapshots];\n    }\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      missingClientEdges: currentSnapshot.missingClientEdges,\n      missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields,\n      relayResolverErrors: currentSnapshot.relayResolverErrors\n    };\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n  _proto2.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this7 = this;\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this7.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n  _proto2._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this8 = this;\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n    if (pendingOperationsResult == null) {\n      return null;\n    }\n\n    // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this8._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this8._cache[\"delete\"](cacheKey);\n    });\n    // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n    promise.displayName = networkPromise.displayName;\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n  _proto2._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n    var currentFragmentResult = this._cache.get(cacheKey);\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n  return FragmentResourceImpl;\n}();\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n  if (cached) {\n    return cached;\n  }\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar warning = require(\"fbjs/lib/warning\");\nvar implementation = null;\nfunction inject(impl) {\n  process.env.NODE_ENV !== \"production\" ? warning(implementation !== null, 'Relay HooksImplementation was injected twice.') : void 0;\n  implementation = impl;\n}\nfunction get() {\n  return implementation;\n}\nmodule.exports = {\n  inject: inject,\n  get: get\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar invariant = require('invariant');\n/**\n * JS maps (both plain objects and Map) maintain key insertion\n * order, which means there is an easy way to simulate LRU behavior\n * that should also perform quite well:\n *\n * To insert a new value, first delete the key from the inner _map,\n * then _map.set(k, v). By deleting and reinserting, you ensure that the\n * map sees the key as the last inserted key.\n *\n * Get does the same: if the key is present, delete and reinsert it.\n */\nvar LRUCache = /*#__PURE__*/function () {\n  function LRUCache(capacity) {\n    this._capacity = capacity;\n    !(this._capacity > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : invariant(false) : void 0;\n    this._map = new Map();\n  }\n  var _proto = LRUCache.prototype;\n  _proto.set = function set(key, value) {\n    this._map[\"delete\"](key);\n    this._map.set(key, value);\n    if (this._map.size > this._capacity) {\n      var firstKey = this._map.keys().next();\n      if (!firstKey.done) {\n        this._map[\"delete\"](firstKey.value);\n      }\n    }\n  };\n  _proto.get = function get(key) {\n    var value = this._map.get(key);\n    if (value != null) {\n      this._map[\"delete\"](key);\n      this._map.set(key, value);\n    }\n    return value;\n  };\n  _proto.has = function has(key) {\n    return this._map.has(key);\n  };\n  _proto[\"delete\"] = function _delete(key) {\n    this._map[\"delete\"](key);\n  };\n  _proto.size = function size() {\n    return this._map.size;\n  };\n  _proto.capacity = function capacity() {\n    return this._capacity - this._map.size;\n  };\n  _proto.clear = function clear() {\n    this._map.clear();\n  };\n  return LRUCache;\n}();\nfunction create(capacity) {\n  return new LRUCache(capacity);\n}\nmodule.exports = {\n  create: create\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n// This contextual profiler can be used to wrap a react sub-tree. It will bind\n// the RelayProfiler during the render phase of these components. Allows\n// collecting metrics for a specific part of your application.\n\n'use strict';\n\nvar React = require('react');\nvar ProfilerContext = React.createContext({\n  wrapPrepareQueryResource: function wrapPrepareQueryResource(cb) {\n    return cb();\n  }\n});\nmodule.exports = ProfilerContext;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar LRUCache = require('./LRUCache');\nvar SuspenseResource = require('./SuspenseResource');\nvar invariant = require('invariant');\nvar _require = require('relay-runtime'),\n  isPromise = _require.isPromise;\nvar warning = require(\"fbjs/lib/warning\");\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar DEFAULT_LIVE_FETCH_POLICY = 'store-and-network';\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n  return cacheIdentifier;\n}\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\nvar nextID = 200000;\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var currentNetworkSubscription = networkSubscription;\n  var suspenseResource = new SuspenseResource(function (environment) {\n    var retention = environment.retain(operation);\n    return {\n      dispose: function dispose() {\n        // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n        if (isLiveQuery && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n        retention.dispose();\n        onDispose(cacheEntry);\n      }\n    };\n  });\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      return suspenseResource.temporaryRetain(environment);\n    },\n    permanentRetain: function permanentRetain(environment) {\n      return suspenseResource.permanentRetain(environment);\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      suspenseResource.releaseTemporaryRetain();\n    }\n  };\n  return cacheEntry;\n}\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n  var _proto = QueryResourceImpl.prototype;\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */;\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n\n    // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n    var cacheEntry = this._cache.get(cacheIdentifier);\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    }\n\n    // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n      throw cachedValue;\n    }\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n    return cachedValue;\n  }\n\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */;\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n      operation = queryResult.operation;\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n    var disposable = cacheEntry.permanentRetain(environment);\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n    return cacheEntry;\n  };\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n    var environment = this._environment;\n\n    // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n    // Different definitions for Promise in our repos can cause this variable\n    // to cause errors when synced elsewhere\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    }\n\n    // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription);\n\n          // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n\n          // We will ignore errors for any incremental payloads we receive.\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%s` returned an error: `%s`.', operation.fragment.node.name, String(_error.message)) : void 0;\n          }\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        });\n\n        // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n    var cacheEntry = this._cache.get(cacheIdentifier);\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n    return cacheEntry;\n  };\n  return QueryResourceImpl;\n}();\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n  if (cached) {\n    return cached;\n  }\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar ReactRelayContext = require('./../ReactRelayContext');\nvar React = require('react');\nvar useMemo = React.useMemo;\nfunction RelayEnvironmentProvider(props) {\n  var children = props.children,\n    environment = props.environment,\n    getEnvironmentForActor = props.getEnvironmentForActor;\n  var context = useMemo(function () {\n    return {\n      environment: environment,\n      getEnvironmentForActor: getEnvironmentForActor\n    };\n  }, [environment, getEnvironmentForActor]);\n  return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n    value: context\n  }, children);\n}\nmodule.exports = RelayEnvironmentProvider;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar invariant = require('invariant');\nvar TEMPORARY_RETAIN_DURATION_MS = 5 * 60 * 1000;\n\n/**\n * Allows you to retain a resource as part of a component lifecycle accounting\n * for Suspense. You temporarily retain the resource during render, then\n * permanently retain it during commit and release it during unmount.\n */\nvar SuspenseResource = /*#__PURE__*/function () {\n  function SuspenseResource(retain) {\n    var _this = this;\n    (0, _defineProperty2[\"default\"])(this, \"_retainCount\", 0);\n    (0, _defineProperty2[\"default\"])(this, \"_retainDisposable\", null);\n    (0, _defineProperty2[\"default\"])(this, \"_releaseTemporaryRetain\", null);\n    this._retain = function (environment) {\n      _this._retainCount++;\n      if (_this._retainCount === 1) {\n        _this._retainDisposable = retain(environment);\n      }\n      return {\n        dispose: function dispose() {\n          _this._retainCount = Math.max(0, _this._retainCount - 1);\n          if (_this._retainCount === 0) {\n            !(_this._retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n            _this._retainDisposable.dispose();\n            _this._retainDisposable = null;\n          }\n        }\n      };\n    };\n  }\n  var _proto = SuspenseResource.prototype;\n  _proto.temporaryRetain = function temporaryRetain(environment) {\n    var _this2 = this;\n    var _this$_releaseTempora;\n    // If we're executing in a server environment, there's no need\n    // to create temporary retains, since the component will never commit.\n    if (environment.isServer()) {\n      return {\n        dispose: function dispose() {}\n      };\n    }\n\n    // temporaryRetain is called during the render phase. However,\n    // given that we can't tell if this render will eventually commit or not,\n    // we create a timer to autodispose of this retain in case the associated\n    // component never commits.\n    // If the component /does/ commit, permanentRetain will clear this timeout\n    // and permanently retain the data.\n    var retention = this._retain(environment);\n    var releaseQueryTimeout = null;\n    var releaseTemporaryRetain = function releaseTemporaryRetain() {\n      clearTimeout(releaseQueryTimeout);\n      releaseQueryTimeout = null;\n      _this2._releaseTemporaryRetain = null;\n      retention.dispose();\n    };\n    releaseQueryTimeout = setTimeout(releaseTemporaryRetain, TEMPORARY_RETAIN_DURATION_MS);\n\n    // NOTE: Since temporaryRetain can be called multiple times, we release\n    // the previous temporary retain after we re-establish a new one, since\n    // we only ever need a single temporary retain until the permanent retain is\n    // established.\n    // temporaryRetain may be called multiple times by React during the render\n    // phase, as well as multiple times by other query components that are\n    // rendering the same query/variables.\n    (_this$_releaseTempora = this._releaseTemporaryRetain) === null || _this$_releaseTempora === void 0 ? void 0 : _this$_releaseTempora.call(this);\n    this._releaseTemporaryRetain = releaseTemporaryRetain;\n    return {\n      dispose: function dispose() {\n        var _this$_releaseTempora2;\n        (_this$_releaseTempora2 = _this2._releaseTemporaryRetain) === null || _this$_releaseTempora2 === void 0 ? void 0 : _this$_releaseTempora2.call(_this2);\n      }\n    };\n  };\n  _proto.permanentRetain = function permanentRetain(environment) {\n    var disposable = this._retain(environment);\n    this.releaseTemporaryRetain();\n    return disposable;\n  };\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain() {\n    var _this$_releaseTempora3;\n    (_this$_releaseTempora3 = this._releaseTemporaryRetain) === null || _this$_releaseTempora3 === void 0 ? void 0 : _this$_releaseTempora3.call(this);\n    this._releaseTemporaryRetain = null;\n  };\n  _proto.getRetainCount = function getRetainCount() {\n    return this._retainCount;\n  };\n  return SuspenseResource;\n}();\nmodule.exports = SuspenseResource;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _require = require('./loadQuery'),\n  loadQuery = _require.loadQuery;\nfunction loadEntryPoint(environmentProvider, entryPoint, entryPointParams) {\n  // Start loading the code for the entrypoint\n  var loadingPromise = null;\n  if (entryPoint.root.getModuleIfRequired() == null) {\n    loadingPromise = entryPoint.root.load();\n  }\n  var preloadProps = entryPoint.getPreloadProps(entryPointParams);\n  var queries = preloadProps.queries,\n    entryPoints = preloadProps.entryPoints,\n    extraProps = preloadProps.extraProps;\n  var preloadedQueries = {};\n  var preloadedEntryPoints = {};\n  if (queries != null) {\n    var queriesPropNames = Object.keys(queries);\n    queriesPropNames.forEach(function (queryPropName) {\n      var _queries$queryPropNam = queries[queryPropName],\n        environmentProviderOptions = _queries$queryPropNam.environmentProviderOptions,\n        options = _queries$queryPropNam.options,\n        parameters = _queries$queryPropNam.parameters,\n        variables = _queries$queryPropNam.variables;\n      var environment = environmentProvider.getEnvironment(environmentProviderOptions);\n\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      preloadedQueries[queryPropName] = loadQuery(environment, parameters, variables, {\n        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n        networkCacheConfig: options === null || options === void 0 ? void 0 : options.networkCacheConfig,\n        __nameForWarning: 'loadEntryPoint'\n      }, environmentProviderOptions);\n    });\n  }\n  if (entryPoints != null) {\n    var entryPointPropNames = Object.keys(entryPoints);\n    entryPointPropNames.forEach(function (entryPointPropName) {\n      var entryPointDescription = entryPoints[entryPointPropName];\n      if (entryPointDescription == null) {\n        return;\n      }\n      var nestedEntryPoint = entryPointDescription.entryPoint,\n        nestedParams = entryPointDescription.entryPointParams;\n      preloadedEntryPoints[entryPointPropName] = loadEntryPoint(environmentProvider, nestedEntryPoint, nestedParams);\n    });\n  }\n  var isDisposed = false;\n  return {\n    dispose: function dispose() {\n      if (isDisposed) {\n        return;\n      }\n      if (preloadedQueries != null) {\n        Object.values(preloadedQueries).forEach(function (_ref) {\n          var innerDispose = _ref.dispose;\n          innerDispose();\n        });\n      }\n      if (preloadedEntryPoints != null) {\n        Object.values(preloadedEntryPoints).forEach(function (_ref2) {\n          var innerDispose = _ref2.dispose;\n          innerDispose();\n        });\n      }\n      isDisposed = true;\n    },\n    entryPoints: preloadedEntryPoints,\n    extraProps: extraProps !== null && extraProps !== void 0 ? extraProps : null,\n    getComponent: function getComponent() {\n      var componentModule = entryPoint.root.getModuleIfRequired();\n      if (componentModule == null) {\n        var _loadingPromise;\n        loadingPromise = (_loadingPromise = loadingPromise) !== null && _loadingPromise !== void 0 ? _loadingPromise : entryPoint.root.load();\n        throw loadingPromise;\n      }\n\n      // On certain platforms, getting an es6 module with a default export from a JSResource will return an object like\n      // {default: module}, so let's assume that if the \"component\" has a static property named \"default\"\n      // that it's actually an es6 module wrapper, so unwrap it. This won't work for React classes with a static property named \"default\", but\n      // that's probably a worthwhile trade-off.\n      var component =\n      // $FlowIgnore[prop-missing]\n      componentModule[\"default\"] != null ? componentModule[\"default\"] : componentModule;\n      // $FlowFixMe[incompatible-cast] - trust me Flow, its entryPoint component\n      return component;\n    },\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get isDisposed() {\n      return isDisposed;\n    },\n    queries: preloadedQueries,\n    rootModuleID: entryPoint.root.getModuleId()\n  };\n}\nmodule.exports = loadEntryPoint;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar invariant = require('invariant');\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  fetchQueryDeduped = _require.__internal.fetchQueryDeduped,\n  Observable = _require.Observable,\n  PreloadableQueryRegistry = _require.PreloadableQueryRegistry,\n  RelayFeatureFlags = _require.RelayFeatureFlags,\n  ReplaySubject = _require.ReplaySubject,\n  createOperationDescriptor = _require.createOperationDescriptor,\n  getRequest = _require.getRequest,\n  getRequestIdentifier = _require.getRequestIdentifier;\nvar warning = require(\"fbjs/lib/warning\");\nvar RenderDispatcher = null;\nvar fetchKey = 100001;\nfunction useTrackLoadQueryInRender() {\n  if (RenderDispatcher === null) {\n    var _React$__SECRET_INTER, _React$__SECRET_INTER2;\n    // Flow does not know of React internals (rightly so), but we need to\n    // ensure here that this function isn't called inside render.\n    RenderDispatcher = // $FlowFixMe[prop-missing]\n    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;\n  }\n}\nfunction loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {\n  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy;\n  // This code ensures that we don't call loadQuery during render.\n  var CurrentDispatcher = // $FlowFixMe[prop-missing]\n  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;\n  process.env.NODE_ENV !== \"production\" ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0;\n\n  // Every time you call loadQuery, we will generate a new fetchKey.\n  // This will ensure that every query reference that is created and\n  // passed to usePreloadedQuery is independently evaluated,\n  // even if they are for the same query/variables.\n  // Specifically, we want to avoid a case where we try to refetch a\n  // query by calling loadQuery a second time, and have the Suspense\n  // cache in usePreloadedQuery reuse the cached result instead of\n  // re-evaluating the new query ref and triggering a refetch if\n  // necessary.\n  fetchKey++;\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {\n    force: true\n  });\n\n  // executeWithNetworkSource will retain and execute an operation\n  // against the Relay store, given an Observable that would provide\n  // the network events for the operation.\n  var retainReference;\n  var didExecuteNetworkSource = false;\n  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {\n    didExecuteNetworkSource = true;\n    return environment.executeWithSource({\n      operation: operation,\n      source: networkObservable\n    });\n  };\n\n  // N.B. For loadQuery, we unconventionally want to return an Observable\n  // that isn't lazily executed, meaning that we don't want to wait\n  // until the returned Observable is subscribed to to actually start\n  // fetching and executing an operation; i.e. we want to execute the\n  // operation eagerly, when loadQuery is called.\n  // For this reason, we use an intermediate executionSubject which\n  // allows us to capture the events that occur during the eager execution\n  // of the operation, and then replay them to the Observable we\n  // ultimately return.\n  var executionSubject = new ReplaySubject();\n  var returnedObservable = Observable.create(function (sink) {\n    return executionSubject.subscribe(sink);\n  });\n  var unsubscribeFromNetworkRequest;\n  var networkError = null;\n  // makeNetworkRequest will immediately start a raw network request if\n  // one isn't already in flight and return an Observable that when\n  // subscribed to will replay the network events that have occured so far,\n  // as well as subsequent events.\n  var didMakeNetworkRequest = false;\n  var makeNetworkRequest = function makeNetworkRequest(params) {\n    // N.B. this function is called synchronously or not at all\n    // didMakeNetworkRequest is safe to rely on in the returned value\n    // Even if the request gets deduped below, we still wan't to return an\n    // observable that provides the replayed network events for the query,\n    // so we set this to true before deduping, to guarantee that the\n    // `source` observable is returned.\n    didMakeNetworkRequest = true;\n    var observable;\n    var subject = new ReplaySubject();\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // Here, we are calling fetchQueryDeduped at the network layer level,\n      // which ensures that only a single network request is active for a given\n      // (environment, identifier) pair.\n      // Since network requests can be started /before/ we have the query ast\n      // necessary to process the results, we need to dedupe the raw requests\n      // separately from deduping the operation execution; specifically,\n      // if `loadQuery` is called multiple times before the query ast is available,\n      // we still want the network request to be deduped.\n      // - If a duplicate active network request is found, it will return an\n      // Observable that replays the events of the already active request.\n      // - If no duplicate active network request is found, it will call the fetchFn\n      // to start the request, and return an Observable that will replay\n      // the events from the network request.\n      // We provide an extra key to the identifier to distinguish deduping\n      // of raw network requests vs deduping of operation executions.\n      var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);\n      observable = fetchQueryDeduped(environment, identifier, function () {\n        var network = environment.getNetwork();\n        return network.execute(params, variables, networkCacheConfig);\n      });\n    } else {\n      var network = environment.getNetwork();\n      observable = network.execute(params, variables, networkCacheConfig);\n    }\n    var _observable$subscribe = observable.subscribe({\n        error: function error(err) {\n          networkError = err;\n          subject.error(err);\n        },\n        next: function next(data) {\n          subject.next(data);\n        },\n        complete: function complete() {\n          subject.complete();\n        }\n      }),\n      unsubscribe = _observable$subscribe.unsubscribe;\n    unsubscribeFromNetworkRequest = unsubscribe;\n    return Observable.create(function (sink) {\n      var subjectSubscription = subject.subscribe(sink);\n      return function () {\n        subjectSubscription.unsubscribe();\n        unsubscribeFromNetworkRequest();\n      };\n    });\n  };\n  var unsubscribeFromExecution;\n  var executeDeduped = function executeDeduped(operation, fetchFn) {\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),\n      // we are guaranteed to have started a network request. We set this to\n      // true here as well since `makeNetworkRequest` might get skipped in the case\n      // where the query ast is already available and the query executions get deduped.\n      // Even if the execution gets deduped below, we still wan't to return\n      // an observable that provides the replayed network events for the query,\n      // so we set this to true before deduping, to guarantee that the `source`\n      // observable is returned.\n      didMakeNetworkRequest = true;\n    }\n\n    // Here, we are calling fetchQueryDeduped, which ensures that only\n    // a single operation is active for a given (environment, identifier) pair,\n    // and also tracks the active state of the operation, which is necessary\n    // for our Suspense infra to later be able to suspend (or not) on\n    // active operations. Even though we already dedupe raw network requests,\n    // we also need to dedupe and keep track operation execution for our Suspense\n    // infra, and we also want to avoid processing responses more than once, for\n    // the cases where `loadQuery` might be called multiple times after the query ast\n    // is available.\n    // - If a duplicate active operation is found, it will return an\n    // Observable that replays the events of the already active operation.\n    // - If no duplicate active operation is found, it will call the fetchFn\n    // to execute the operation, and return an Observable that will provide\n    // the events for executing the operation.\n    var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({\n      error: function error(err) {\n        executionSubject.error(err);\n      },\n      next: function next(data) {\n        executionSubject.next(data);\n      },\n      complete: function complete() {\n        executionSubject.complete();\n      }\n    });\n    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;\n  };\n  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {\n    var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);\n    retainReference = environment.retain(operation);\n    if (fetchPolicy === 'store-only') {\n      return;\n    }\n\n    // N.B. If the fetch policy allows fulfillment from the store but the\n    // environment already has the data for that operation cached in the store,\n    // then we do nothing.\n    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';\n    if (shouldFetch) {\n      executeDeduped(operation, function () {\n        // N.B. Since we have the operation synchronously available here,\n        // we can immediately fetch and execute the operation.\n        var networkObservable = makeNetworkRequest(concreteRequest.params);\n        var executeObservable = executeWithNetworkSource(operation, networkObservable);\n        return executeObservable;\n      });\n    }\n  };\n  var params;\n  var cancelOnLoadCallback;\n  var queryId;\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    var preloadableConcreteRequest = preloadableRequest;\n    params = preloadableConcreteRequest.params;\n    var _params = params;\n    queryId = _params.id;\n    !(queryId !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;\n    var _module = PreloadableQueryRegistry.get(queryId);\n    if (_module != null) {\n      checkAvailabilityAndExecute(_module);\n    } else {\n      // If the module isn't synchronously available, we launch the\n      // network request immediately if the fetchPolicy might produce\n      // a network fetch, regardless of the state of the store cache. We\n      // do this because we can't check if a query is cached without the\n      // ast, and we know that if we don't have the query ast\n      // available, then this query could've never been written to the\n      // store in the first place, so it couldn't have been cached.\n      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params);\n      // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function (preloadedModule) {\n        cancelOnLoadCallback();\n        var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);\n        retainReference = environment.retain(operation);\n        if (networkObservable != null) {\n          executeDeduped(operation, function () {\n            return executeWithNetworkSource(operation, networkObservable);\n          });\n        }\n      });\n      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;\n    }\n  } else {\n    var graphQlTaggedNode = preloadableRequest;\n    var request = getRequest(graphQlTaggedNode);\n    params = request.params;\n    queryId = params.cacheID != null ? params.cacheID : params.id;\n    checkAvailabilityAndExecute(request);\n  }\n  var isDisposed = false;\n  var isReleased = false;\n  var isNetworkRequestCancelled = false;\n  var releaseQuery = function releaseQuery() {\n    if (isReleased) {\n      return;\n    }\n    retainReference && retainReference.dispose();\n    isReleased = true;\n  };\n  var cancelNetworkRequest = function cancelNetworkRequest() {\n    if (isNetworkRequestCancelled) {\n      return;\n    }\n    if (didExecuteNetworkSource) {\n      unsubscribeFromExecution && unsubscribeFromExecution();\n    } else {\n      unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();\n    }\n    cancelOnLoadCallback && cancelOnLoadCallback();\n    isNetworkRequestCancelled = true;\n  };\n  return {\n    kind: 'PreloadedQuery',\n    environment: environment,\n    environmentProviderOptions: environmentProviderOptions,\n    dispose: function dispose() {\n      if (isDisposed) {\n        return;\n      }\n      releaseQuery();\n      cancelNetworkRequest();\n      isDisposed = true;\n    },\n    releaseQuery: releaseQuery,\n    cancelNetworkRequest: cancelNetworkRequest,\n    fetchKey: fetchKey,\n    id: queryId,\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get isDisposed() {\n      return isDisposed || isReleased;\n    },\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get networkError() {\n      return networkError;\n    },\n    name: params.name,\n    networkCacheConfig: networkCacheConfig,\n    fetchPolicy: fetchPolicy,\n    source: didMakeNetworkRequest ? returnedObservable : undefined,\n    variables: variables\n  };\n}\nmodule.exports = {\n  loadQuery: loadQuery,\n  useTrackLoadQueryInRender: useTrackLoadQueryInRender\n};","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar useLazyLoadQuery = require('./useLazyLoadQuery');\n\n/**\n * This hook can be used to render client-only queries.\n * These queries are consist of queries for client-only data,\n * schematized via local schema extensions and/or Relay resolvers.\n */\nfunction useClientQuery(gqlQuery, variables, options) {\n  // $FlowFixMe[incompatible-type] client queries can be used with useLazyLoadQuery, but only with `store-only` policy.\n  var query = gqlQuery;\n  return useLazyLoadQuery(query, variables, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options), {}, {\n    fetchPolicy: 'store-only'\n  }));\n}\nmodule.exports = useClientQuery;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\nvar loadEntryPoint = require('./loadEntryPoint');\nvar _require = require('./loadQuery'),\n  useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\nvar useIsMountedRef = require('./useIsMountedRef');\nvar _require2 = require('react'),\n  useCallback = _require2.useCallback,\n  useEffect = _require2.useEffect,\n  useRef = _require2.useRef,\n  useState = _require2.useState;\nvar initialNullEntryPointReferenceState = {\n  kind: 'NullEntryPointReference'\n};\nfunction useLoadEntryPoint(environmentProvider, entryPoint, options) {\n  var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;\n  /**\n   * We want to always call `entryPointReference.dispose()` for every call to\n   * `setEntryPointReference(loadEntryPoint(...))` so that no leaks of data in Relay\n   * stores will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each ref\n   * with `useEffect(() => () => entryPointReference.dispose(), [entryPointReference])`.\n   *\n   * Instead, we keep track of each call to `loadEntryPoint` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded entry point references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * entry point references.\n   */\n\n  useTrackLoadQueryInRender();\n  var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;\n  var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;\n  var isMountedRef = useIsMountedRef();\n  var undisposedEntryPointReferencesRef = useRef(new Set([initialEntryPointReferenceInternal]));\n  var _useState = useState(initialEntryPointReferenceInternal),\n    entryPointReference = _useState[0],\n    setEntryPointReference = _useState[1];\n  var _useState2 = useState(initialEntryPointParamsInternal),\n    entryPointParams = _useState2[0],\n    setEntryPointParams = _useState2[1];\n  var disposeEntryPoint = useCallback(function () {\n    if (isMountedRef.current) {\n      var nullEntryPointReference = {\n        kind: 'NullEntryPointReference'\n      };\n      undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);\n      setEntryPointReference(nullEntryPointReference);\n    }\n  }, [setEntryPointReference, isMountedRef]);\n  var entryPointLoaderCallback = useCallback(function (params) {\n    if (isMountedRef.current) {\n      var updatedEntryPointReference = loadEntryPoint(environmentProvider, entryPoint, params);\n      undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);\n      setEntryPointReference(updatedEntryPointReference);\n      setEntryPointParams(params);\n    }\n  }, [environmentProvider, entryPoint, setEntryPointReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current entryPointReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current entryPointReference disposed, we need to load the entryPoint again\n      // and force a re-render by calling entryPointLoaderCallback again,\n      // so that the entryPointReference's queries are correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n      if (entryPointReference.kind !== 'NullEntryPointReference' && entryPointParams != null) {\n        entryPointLoaderCallback(entryPointParams);\n      }\n      return;\n    }\n\n    // When a new entryPointReference is committed, we iterate over all\n    // entrypoint refs in undisposedEntryPointReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling entrypoint references for the\n    // case that loadEntryPoint is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedEntryPointReferences until we find entryPointReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find entryPointReference in the set, because if a\n    // state change results in a commit, no state changes initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with commits that were initiated prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n    var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedEntryPointReferences),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedEntryPointReference = _step.value;\n          if (undisposedEntryPointReference === entryPointReference) {\n            break;\n          }\n          undisposedEntryPointReferences[\"delete\"](undisposedEntryPointReference);\n          if (undisposedEntryPointReference.kind !== 'NullEntryPointReference') {\n            undisposedEntryPointReference.dispose();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [entryPointReference, entryPointParams, entryPointLoaderCallback, isMountedRef]);\n  useEffect(function () {\n    return function disposeAllRemainingEntryPointReferences() {\n      // undisposedEntryPointReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedEntryPointReferencesRef.current),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var unhandledStateChange = _step2.value;\n          if (unhandledStateChange.kind !== 'NullEntryPointReference') {\n            unhandledStateChange.dispose();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, []);\n  return [entryPointReference.kind === 'NullEntryPointReference' ? null : entryPointReference, entryPointLoaderCallback, disposeEntryPoint];\n}\nmodule.exports = useLoadEntryPoint;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar useUnsafeRef_DEPRECATED = require('./useUnsafeRef_DEPRECATED');\nvar _require = require('react'),\n  useCallback = _require.useCallback,\n  useEffect = _require.useEffect;\n\n/**\n * This hook returns a mutable React ref that holds the value of whether a\n * fetch request is in flight. The reason this is a mutable ref instead of\n * state is because we don't actually want to trigger an update when this\n * changes, but instead synchronously keep track of whether the network request\n * is in flight, for example in order to bail out of a request if one is\n * already in flight. If this was state, due to the nature of concurrent\n * updates, this value wouldn't be in sync with when the request is actually\n * in flight.\n * The additional functions returned by this Hook can be used to mutate\n * the ref.\n */\nfunction useFetchTrackingRef() {\n  var subscriptionRef = useUnsafeRef_DEPRECATED(null);\n  var isFetchingRef = useUnsafeRef_DEPRECATED(false);\n  var disposeFetch = useCallback(function () {\n    if (subscriptionRef.current != null) {\n      subscriptionRef.current.unsubscribe();\n      subscriptionRef.current = null;\n    }\n    isFetchingRef.current = false;\n  }, []);\n  var startFetch = useCallback(function (subscription) {\n    subscriptionRef.current = subscription;\n    isFetchingRef.current = true;\n  }, []);\n  var completeFetch = useCallback(function () {\n    subscriptionRef.current = null;\n    isFetchingRef.current = false;\n  }, []);\n\n  // Dipose of ongoing fetch on unmount\n  useEffect(function () {\n    return disposeFetch;\n  }, [disposeFetch]);\n  return {\n    isFetchingRef: isFetchingRef,\n    startFetch: startFetch,\n    disposeFetch: disposeFetch,\n    completeFetch: completeFetch\n  };\n}\nmodule.exports = useFetchTrackingRef;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar HooksImplementation = require('./HooksImplementation');\nvar _require = require('./loadQuery'),\n  useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\nvar useFragmentNode = require('./useFragmentNode');\nvar useStaticFragmentNodeWarning = require('./useStaticFragmentNodeWarning');\nvar _require2 = require('react'),\n  useDebugValue = _require2.useDebugValue;\nvar _require3 = require('relay-runtime'),\n  getFragment = _require3.getFragment;\nfunction useFragment_LEGACY(fragment, key) {\n  // We need to use this hook in order to be able to track if\n  // loadQuery was called during render\n  useTrackLoadQueryInRender();\n  var fragmentNode = getFragment(fragment);\n  useStaticFragmentNodeWarning(fragmentNode, 'first argument of useFragment()');\n  var _useFragmentNode = useFragmentNode(fragmentNode, key, 'useFragment()'),\n    data = _useFragmentNode.data;\n  if (process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue({\n      fragment: fragmentNode.name,\n      data: data\n    });\n  }\n  return data;\n}\nfunction useFragment(fragment, key) {\n  var impl = HooksImplementation.get();\n  if (impl) {\n    // $FlowFixMe This is safe because impl.useFragment has the type of useFragment...\n    return impl.useFragment(fragment, key);\n    // (i.e. type declared above, but not the supertype used in this function definition)\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useFragment_LEGACY(fragment, key);\n  }\n}\nmodule.exports = useFragment;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _require = require('./FragmentResource'),\n  getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar useUnsafeRef_DEPRECATED = require('./useUnsafeRef_DEPRECATED');\nvar _require2 = require('react'),\n  useEffect = _require2.useEffect,\n  useState = _require2.useState;\nvar _require3 = require('relay-runtime'),\n  getFragmentIdentifier = _require3.getFragmentIdentifier;\nvar warning = require(\"fbjs/lib/warning\");\nfunction useFragmentNode(fragmentNode, fragmentRef, componentDisplayName) {\n  var environment = useRelayEnvironment();\n  var FragmentResource = getFragmentResourceForEnvironment(environment);\n  var isMountedRef = useUnsafeRef_DEPRECATED(false);\n  var _useState = useState(0),\n    forceUpdate = _useState[1];\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);\n\n  // Read fragment data; this might suspend.\n  var fragmentResult = FragmentResource.readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName);\n  var isListeningForUpdatesRef = useUnsafeRef_DEPRECATED(true);\n  function enableStoreUpdates() {\n    isListeningForUpdatesRef.current = true;\n    var didMissUpdates = FragmentResource.checkMissedUpdates(fragmentResult)[0];\n    if (didMissUpdates) {\n      handleDataUpdate();\n    }\n  }\n  function disableStoreUpdates() {\n    isListeningForUpdatesRef.current = false;\n  }\n  function handleDataUpdate() {\n    if (isMountedRef.current === false || isListeningForUpdatesRef.current === false) {\n      return;\n    }\n\n    // React bails out on noop state updates as an optimization.\n    // If we want to force an update via setState, we need to pass an value.\n    // The actual value can be arbitrary though, e.g. an incremented number.\n    forceUpdate(function (count) {\n      return count + 1;\n    });\n  }\n\n  // Establish Relay store subscriptions in the commit phase, only if\n  // rendering for the first time, or if we need to subscribe to new data\n  // If the fragment identifier changes, it means that the variables on the\n  // fragment owner changed, or the fragment ref points to different records.\n  // In this case, we need to resubscribe to the Relay store.\n  useEffect(function () {\n    isMountedRef.current = true;\n    var disposable = FragmentResource.subscribe(fragmentResult, handleDataUpdate);\n    return function () {\n      // When unmounting or resubscribing to new data, clean up current\n      // subscription. This will also make sure fragment data is no longer\n      // cached so that next time it its read, it will be freshly read from\n      // the Relay store\n      isMountedRef.current = false;\n      disposable.dispose();\n    };\n    // NOTE: We disable react-hooks-deps warning because environment and fragmentIdentifier\n    // is capturing all information about whether the effect should be re-ran.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [environment, fragmentIdentifier]);\n  if (process.env.NODE_ENV !== \"production\") {\n    if (fragmentRef != null && (fragmentResult.data === undefined || Array.isArray(fragmentResult.data) && fragmentResult.data.length > 0 && fragmentResult.data.every(function (data) {\n      return data === undefined;\n    }))) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + \"Make sure that that `%s`'s parent isn't \" + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n    }\n  }\n  return {\n    // $FlowFixMe[incompatible-return]\n    data: fragmentResult.data,\n    disableStoreUpdates: disableStoreUpdates,\n    enableStoreUpdates: enableStoreUpdates\n  };\n}\nmodule.exports = useFragmentNode;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _require = require('react'),\n  useEffect = _require.useEffect,\n  useRef = _require.useRef;\nfunction useIsMountedRef() {\n  var isMountedRef = useRef(true);\n  useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef;\n}\nmodule.exports = useIsMountedRef;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar invariant = require('invariant');\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  getObservableForActiveRequest = _require.__internal.getObservableForActiveRequest,\n  getSelector = _require.getSelector;\nvar useEffect = React.useEffect,\n  useState = React.useState,\n  useMemo = React.useMemo;\nfunction useIsOperationNodeActive(fragmentNode, fragmentRef) {\n  var environment = useRelayEnvironment();\n  var observable = useMemo(function () {\n    var selector = getSelector(fragmentNode, fragmentRef);\n    if (selector == null) {\n      return null;\n    }\n    !(selector.kind === 'SingularReaderSelector') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'useIsOperationNodeActive: Plural fragments are not supported.') : invariant(false) : void 0;\n    return getObservableForActiveRequest(environment, selector.owner);\n  }, [environment, fragmentNode, fragmentRef]);\n  var _useState = useState(observable != null),\n    isActive = _useState[0],\n    setIsActive = _useState[1];\n  useEffect(function () {\n    var subscription;\n    setIsActive(observable != null);\n    if (observable != null) {\n      var onCompleteOrError = function onCompleteOrError() {\n        setIsActive(false);\n      };\n      subscription = observable.subscribe({\n        complete: onCompleteOrError,\n        error: onCompleteOrError\n      });\n    }\n    return function () {\n      if (subscription) {\n        subscription.unsubscribe();\n      }\n    };\n  }, [observable]);\n  return isActive;\n}\nmodule.exports = useIsOperationNodeActive;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _require = require('./loadQuery'),\n  useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\nvar useLazyLoadQueryNode = require('./useLazyLoadQueryNode');\nvar useMemoOperationDescriptor = require('./useMemoOperationDescriptor');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar _require2 = require('relay-runtime'),\n  fetchQuery = _require2.__internal.fetchQuery;\n\n// This separate type export is only needed as long as we are injecting\n// a separate hooks implementation in ./HooksImplementation -- it can\n// be removed after we stop doing that.\n\nfunction useLazyLoadQuery(gqlQuery, variables, options) {\n  // We need to use this hook in order to be able to track if\n  // loadQuery was called during render\n  useTrackLoadQueryInRender();\n  var environment = useRelayEnvironment();\n  var query = useMemoOperationDescriptor(gqlQuery, variables, options && options.networkCacheConfig ? options.networkCacheConfig : {\n    force: true\n  });\n  var data = useLazyLoadQueryNode({\n    componentDisplayName: 'useLazyLoadQuery()',\n    fetchKey: options === null || options === void 0 ? void 0 : options.fetchKey,\n    fetchObservable: fetchQuery(environment, query),\n    fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n    query: query,\n    renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy\n  });\n  return data;\n}\nmodule.exports = useLazyLoadQuery;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar ProfilerContext = require('./ProfilerContext');\nvar _require = require('./QueryResource'),\n  getQueryCacheIdentifier = _require.getQueryCacheIdentifier,\n  getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;\nvar useFetchTrackingRef = require('./useFetchTrackingRef');\nvar useFragmentNode = require('./useFragmentNode');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar React = require('react');\nvar useContext = React.useContext,\n  useEffect = React.useEffect,\n  useState = React.useState,\n  useRef = React.useRef;\nfunction useLazyLoadQueryNode(_ref) {\n  var query = _ref.query,\n    componentDisplayName = _ref.componentDisplayName,\n    fetchObservable = _ref.fetchObservable,\n    fetchPolicy = _ref.fetchPolicy,\n    fetchKey = _ref.fetchKey,\n    renderPolicy = _ref.renderPolicy;\n  var environment = useRelayEnvironment();\n  var profilerContext = useContext(ProfilerContext);\n  var QueryResource = getQueryResourceForEnvironment(environment);\n  var _useState = useState(0),\n    forceUpdateKey = _useState[0],\n    forceUpdate = _useState[1];\n  var _useFetchTrackingRef = useFetchTrackingRef(),\n    startFetch = _useFetchTrackingRef.startFetch,\n    completeFetch = _useFetchTrackingRef.completeFetch;\n  var cacheBreaker = \"\".concat(forceUpdateKey, \"-\").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : '');\n  var cacheIdentifier = getQueryCacheIdentifier(environment, query, fetchPolicy, renderPolicy, cacheBreaker);\n  var preparedQueryResult = profilerContext.wrapPrepareQueryResource(function () {\n    return QueryResource.prepareWithIdentifier(cacheIdentifier, query, fetchObservable, fetchPolicy, renderPolicy, {\n      start: startFetch,\n      complete: completeFetch,\n      error: completeFetch\n    }, profilerContext);\n  });\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current cached resource will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly attempt to\n      // retain a cached query resource that was disposed, we need to force\n      // a re-render so that the cache entry for this query is re-intiliazed and\n      // and re-evaluated (and potentially cause a refetch).\n      maybeHiddenOrFastRefresh.current = false;\n      forceUpdate(function (n) {\n        return n + 1;\n      });\n      return;\n    }\n    var disposable = QueryResource.retain(preparedQueryResult, profilerContext);\n    return function () {\n      disposable.dispose();\n    };\n    // NOTE: We disable react-hooks-deps warning because the `environment`\n    // and `cacheIdentifier` identities are capturing all information about whether\n    // the effect should be re-executed and the query re-retained.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [environment, cacheIdentifier]);\n  useEffect(function () {\n    // Release any temporary retain that's not released. At this point, if the\n    // cacheIdentifier doesn't change, the query is still permanently retained,\n    // and the temporary retain is redundant.\n    QueryResource.releaseTemporaryRetain(preparedQueryResult);\n    // This effect is intended to run on every commit, thus no dependency\n  });\n\n  var fragmentNode = preparedQueryResult.fragmentNode,\n    fragmentRef = preparedQueryResult.fragmentRef;\n  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),\n    data = _useFragmentNode.data;\n  return data;\n}\nmodule.exports = useLazyLoadQueryNode;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar useFetchTrackingRef = require('./useFetchTrackingRef');\nvar useIsMountedRef = require('./useIsMountedRef');\nvar useIsOperationNodeActive = require('./useIsOperationNodeActive');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar invariant = require('invariant');\nvar _require = require('react'),\n  useCallback = _require.useCallback,\n  useEffect = _require.useEffect,\n  useState = _require.useState;\nvar _require2 = require('relay-runtime'),\n  fetchQuery = _require2.__internal.fetchQuery,\n  ConnectionInterface = _require2.ConnectionInterface,\n  createOperationDescriptor = _require2.createOperationDescriptor,\n  getPaginationVariables = _require2.getPaginationVariables,\n  getSelector = _require2.getSelector,\n  getValueAtPath = _require2.getValueAtPath;\nvar warning = require(\"fbjs/lib/warning\");\nfunction useLoadMoreFunction(args) {\n  var direction = args.direction,\n    fragmentNode = args.fragmentNode,\n    fragmentRef = args.fragmentRef,\n    fragmentIdentifier = args.fragmentIdentifier,\n    fragmentData = args.fragmentData,\n    connectionPathInFragmentData = args.connectionPathInFragmentData,\n    paginationRequest = args.paginationRequest,\n    paginationMetadata = args.paginationMetadata,\n    componentDisplayName = args.componentDisplayName,\n    observer = args.observer,\n    onReset = args.onReset,\n    identifierField = args.identifierField;\n  var environment = useRelayEnvironment();\n  var _useFetchTrackingRef = useFetchTrackingRef(),\n    isFetchingRef = _useFetchTrackingRef.isFetchingRef,\n    startFetch = _useFetchTrackingRef.startFetch,\n    disposeFetch = _useFetchTrackingRef.disposeFetch,\n    completeFetch = _useFetchTrackingRef.completeFetch;\n  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;\n  var isMountedRef = useIsMountedRef();\n  var _useState = useState(environment),\n    mirroredEnvironment = _useState[0],\n    setMirroredEnvironment = _useState[1];\n  var _useState2 = useState(fragmentIdentifier),\n    mirroredFragmentIdentifier = _useState2[0],\n    setMirroredFragmentIdentifier = _useState2[1];\n  var isParentQueryActive = useIsOperationNodeActive(fragmentNode, fragmentRef);\n  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;\n  if (shouldReset) {\n    disposeFetch();\n    onReset();\n    setMirroredEnvironment(environment);\n    setMirroredFragmentIdentifier(fragmentIdentifier);\n  }\n  var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData),\n    cursor = _getConnectionState.cursor,\n    hasMore = _getConnectionState.hasMore;\n\n  // Dispose of pagination requests in flight when unmounting\n  useEffect(function () {\n    return function () {\n      disposeFetch();\n    };\n  }, [disposeFetch]);\n  var loadMore = useCallback(function (count, options) {\n    // TODO(T41131846): Fetch/Caching policies for loadMore\n\n    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;\n    if (isMountedRef.current !== true) {\n      // Bail out and warn if we're trying to paginate after the component\n      // has unmounted\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected fetch on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;\n      return {\n        dispose: function dispose() {}\n      };\n    }\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    if (isFetchingRef.current === true || fragmentData == null || isParentQueryActive) {\n      if (fragmentSelector == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected fetch while using a null fragment ref ' + 'for fragment `%s` in `%s`. When fetching more items, we expect ' + \"initial fragment data to be non-null. Please make sure you're \" + 'passing a valid fragment ref to `%s` before paginating.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n      }\n      if (onComplete) {\n        onComplete(null);\n      }\n      return {\n        dispose: function dispose() {}\n      };\n    }\n    !(fragmentSelector != null && fragmentSelector.kind !== 'PluralReaderSelector') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to be able to find a non-plural fragment owner for ' + \"fragment `%s` when using `%s`. If you're seeing this, \" + 'this is likely a bug in Relay.', fragmentNode.name, componentDisplayName) : invariant(false) : void 0;\n    var parentVariables = fragmentSelector.owner.variables;\n    var fragmentVariables = fragmentSelector.variables;\n    var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables;\n    var baseVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, parentVariables), fragmentVariables);\n    var paginationVariables = getPaginationVariables(direction, count, cursor, baseVariables, (0, _objectSpread2[\"default\"])({}, extraVariables), paginationMetadata);\n\n    // If the query needs an identifier value ('id' or similar) and one\n    // was not explicitly provided, read it from the fragment data.\n    if (identifierField != null) {\n      // @refetchable fragments are guaranteed to have an `id` selection\n      // if the type is Node, implements Node, or is @fetchable. Double-check\n      // that there actually is a value at runtime.\n      if (typeof identifierValue !== 'string') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;\n      }\n      paginationVariables.id = identifierValue;\n    }\n    var paginationQuery = createOperationDescriptor(paginationRequest, paginationVariables, {\n      force: true\n    });\n    fetchQuery(environment, paginationQuery).subscribe((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n      start: function start(subscription) {\n        startFetch(subscription);\n        observer.start && observer.start(subscription);\n      },\n      complete: function complete() {\n        completeFetch();\n        observer.complete && observer.complete();\n        onComplete && onComplete(null);\n      },\n      error: function error(_error) {\n        completeFetch();\n        observer.error && observer.error(_error);\n        onComplete && onComplete(_error);\n      }\n    }));\n    return {\n      dispose: disposeFetch\n    };\n  },\n  // NOTE: We disable react-hooks-deps warning because all values\n  // inside paginationMetadata are static\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [environment, identifierValue, direction, cursor, startFetch, disposeFetch, completeFetch, isFetchingRef, isParentQueryActive, fragmentData, fragmentNode.name, fragmentRef, componentDisplayName]);\n  return [loadMore, hasMore, disposeFetch];\n}\nfunction getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData) {\n  var _pageInfo$END_CURSOR, _pageInfo$START_CURSO;\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n    EDGES = _ConnectionInterface$.EDGES,\n    PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n    HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n    HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n    END_CURSOR = _ConnectionInterface$.END_CURSOR,\n    START_CURSOR = _ConnectionInterface$.START_CURSOR;\n  var connection = getValueAtPath(fragmentData, connectionPathInFragmentData);\n  if (connection == null) {\n    return {\n      cursor: null,\n      hasMore: false\n    };\n  }\n  !(typeof connection === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected connection in fragment `%s` to have been `null`, or ' + 'a plain object with %s and %s properties. Instead got `%s`.', fragmentNode.name, EDGES, PAGE_INFO, connection) : invariant(false) : void 0;\n  var edges = connection[EDGES];\n  var pageInfo = connection[PAGE_INFO];\n  if (edges == null || pageInfo == null) {\n    return {\n      cursor: null,\n      hasMore: false\n    };\n  }\n  !Array.isArray(edges) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, EDGES, edges) : invariant(false) : void 0;\n  !(typeof pageInfo === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, PAGE_INFO, pageInfo) : invariant(false) : void 0;\n  var cursor = direction === 'forward' ? (_pageInfo$END_CURSOR = pageInfo[END_CURSOR]) !== null && _pageInfo$END_CURSOR !== void 0 ? _pageInfo$END_CURSOR : null : (_pageInfo$START_CURSO = pageInfo[START_CURSOR]) !== null && _pageInfo$START_CURSO !== void 0 ? _pageInfo$START_CURSO : null;\n  !(cursor === null || typeof cursor === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected page info for connection in fragment `%s` to have a ' + 'valid `%s`. Instead got `%s`.', fragmentNode.name, START_CURSOR, cursor) : invariant(false) : void 0;\n  var hasMore;\n  if (direction === 'forward') {\n    hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;\n  } else {\n    hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;\n  }\n  return {\n    cursor: cursor,\n    hasMore: hasMore\n  };\n}\nmodule.exports = useLoadMoreFunction;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar useMemoVariables = require('./useMemoVariables');\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  createOperationDescriptor = _require.createOperationDescriptor,\n  getRequest = _require.getRequest;\nvar useMemo = React.useMemo;\nfunction useMemoOperationDescriptor(gqlQuery, variables, cacheConfig) {\n  var memoVariables = useMemoVariables(variables);\n  var memoCacheConfig = useMemoVariables(cacheConfig || {});\n  return useMemo(function () {\n    return createOperationDescriptor(getRequest(gqlQuery), memoVariables, memoCacheConfig);\n  }, [gqlQuery, memoVariables, memoCacheConfig]);\n}\nmodule.exports = useMemoOperationDescriptor;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\nvar _require = require('react'),\n  useState = _require.useState;\n\n/**\n * Memoizes the passed in `variables` object based on `areEqual` equality.\n * This is useful when a `variables` object is used as a value in a depencency\n * array as it might often be constructed during render.\n */\nfunction useMemoVariables(variables) {\n  var _useState = useState(variables),\n    mirroredVariables = _useState[0],\n    setMirroredVariables = _useState[1];\n  if (areEqual(variables, mirroredVariables)) {\n    return mirroredVariables;\n  } else {\n    setMirroredVariables(variables);\n    return variables;\n  }\n}\nmodule.exports = useMemoVariables;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar useIsMountedRef = require('./useIsMountedRef');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar React = require('react');\nvar _require = require('relay-runtime'),\n  defaultCommitMutation = _require.commitMutation;\nvar useState = React.useState,\n  useEffect = React.useEffect,\n  useRef = React.useRef,\n  useCallback = React.useCallback;\nfunction useMutation(mutation) {\n  var commitMutationFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCommitMutation;\n  var environment = useRelayEnvironment();\n  var isMountedRef = useIsMountedRef();\n  var environmentRef = useRef(environment);\n  var mutationRef = useRef(mutation);\n  var inFlightMutationsRef = useRef(new Set());\n  var _useState = useState(false),\n    isMutationInFlight = _useState[0],\n    setMutationInFlight = _useState[1];\n  var cleanup = useCallback(function (disposable) {\n    if (environmentRef.current === environment && mutationRef.current === mutation) {\n      inFlightMutationsRef.current[\"delete\"](disposable);\n      if (isMountedRef.current) {\n        setMutationInFlight(inFlightMutationsRef.current.size > 0);\n      }\n    }\n  }, [environment, isMountedRef, mutation]);\n  useEffect(function () {\n    if (environmentRef.current !== environment || mutationRef.current !== mutation) {\n      inFlightMutationsRef.current = new Set();\n      if (isMountedRef.current) {\n        setMutationInFlight(false);\n      }\n      environmentRef.current = environment;\n      mutationRef.current = mutation;\n    }\n  }, [environment, isMountedRef, mutation]);\n  var commit = useCallback(function (config) {\n    if (isMountedRef.current) {\n      setMutationInFlight(true);\n    }\n    var disposable = commitMutationFn(environment, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, config), {}, {\n      mutation: mutation,\n      onCompleted: function onCompleted(response, errors) {\n        var _config$onCompleted;\n        cleanup(disposable);\n        (_config$onCompleted = config.onCompleted) === null || _config$onCompleted === void 0 ? void 0 : _config$onCompleted.call(config, response, errors);\n      },\n      onError: function onError(error) {\n        var _config$onError;\n        cleanup(disposable);\n        (_config$onError = config.onError) === null || _config$onError === void 0 ? void 0 : _config$onError.call(config, error);\n      },\n      onUnsubscribe: function onUnsubscribe() {\n        var _config$onUnsubscribe;\n        cleanup(disposable);\n        (_config$onUnsubscribe = config.onUnsubscribe) === null || _config$onUnsubscribe === void 0 ? void 0 : _config$onUnsubscribe.call(config);\n      },\n      onNext: function onNext() {\n        var _config$onNext;\n        (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);\n      }\n    }));\n    inFlightMutationsRef.current.add(disposable);\n    return disposable;\n  }, [cleanup, commitMutationFn, environment, isMountedRef, mutation]);\n  return [commit, isMutationInFlight];\n}\nmodule.exports = useMutation;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar HooksImplementation = require('./HooksImplementation');\nvar useLoadMoreFunction = require('./useLoadMoreFunction');\nvar useRefetchableFragmentNode = require('./useRefetchableFragmentNode');\nvar useStaticFragmentNodeWarning = require('./useStaticFragmentNodeWarning');\nvar _require = require('react'),\n  useCallback = _require.useCallback,\n  useDebugValue = _require.useDebugValue,\n  useState = _require.useState;\nvar _require2 = require('relay-runtime'),\n  getFragment = _require2.getFragment,\n  getFragmentIdentifier = _require2.getFragmentIdentifier,\n  getPaginationMetadata = _require2.getPaginationMetadata;\n\n// This separate type export is only needed as long as we are injecting\n// a separate hooks implementation in ./HooksImplementation -- it can\n// be removed after we stop doing that.\n\nfunction usePaginationFragment_LEGACY(fragmentInput, parentFragmentRef) {\n  var fragmentNode = getFragment(fragmentInput);\n  useStaticFragmentNodeWarning(fragmentNode, 'first argument of usePaginationFragment()');\n  var componentDisplayName = 'usePaginationFragment()';\n  var _getPaginationMetadat = getPaginationMetadata(fragmentNode, componentDisplayName),\n    connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData,\n    paginationRequest = _getPaginationMetadat.paginationRequest,\n    paginationMetadata = _getPaginationMetadat.paginationMetadata,\n    identifierField = _getPaginationMetadat.identifierField;\n  var _useRefetchableFragme = useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName),\n    fragmentData = _useRefetchableFragme.fragmentData,\n    fragmentRef = _useRefetchableFragme.fragmentRef,\n    refetch = _useRefetchableFragme.refetch;\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);\n\n  // Backward pagination\n  var _useLoadMore = useLoadMore({\n      componentDisplayName: componentDisplayName,\n      connectionPathInFragmentData: connectionPathInFragmentData,\n      direction: 'backward',\n      fragmentData: fragmentData,\n      fragmentIdentifier: fragmentIdentifier,\n      fragmentNode: fragmentNode,\n      fragmentRef: fragmentRef,\n      identifierField: identifierField,\n      paginationMetadata: paginationMetadata,\n      paginationRequest: paginationRequest\n    }),\n    loadPrevious = _useLoadMore[0],\n    hasPrevious = _useLoadMore[1],\n    isLoadingPrevious = _useLoadMore[2],\n    disposeFetchPrevious = _useLoadMore[3];\n\n  // Forward pagination\n  var _useLoadMore2 = useLoadMore({\n      componentDisplayName: componentDisplayName,\n      connectionPathInFragmentData: connectionPathInFragmentData,\n      direction: 'forward',\n      fragmentData: fragmentData,\n      fragmentIdentifier: fragmentIdentifier,\n      fragmentNode: fragmentNode,\n      fragmentRef: fragmentRef,\n      identifierField: identifierField,\n      paginationMetadata: paginationMetadata,\n      paginationRequest: paginationRequest\n    }),\n    loadNext = _useLoadMore2[0],\n    hasNext = _useLoadMore2[1],\n    isLoadingNext = _useLoadMore2[2],\n    disposeFetchNext = _useLoadMore2[3];\n  var refetchPagination = useCallback(function (variables, options) {\n    disposeFetchNext();\n    disposeFetchPrevious();\n    return refetch(variables, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options), {}, {\n      __environment: undefined\n    }));\n  }, [disposeFetchNext, disposeFetchPrevious, refetch]);\n  if (process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue({\n      fragment: fragmentNode.name,\n      data: fragmentData,\n      hasNext: hasNext,\n      isLoadingNext: isLoadingNext,\n      hasPrevious: hasPrevious,\n      isLoadingPrevious: isLoadingPrevious\n    });\n  }\n  return {\n    data: fragmentData,\n    loadNext: loadNext,\n    loadPrevious: loadPrevious,\n    hasNext: hasNext,\n    hasPrevious: hasPrevious,\n    isLoadingNext: isLoadingNext,\n    isLoadingPrevious: isLoadingPrevious,\n    refetch: refetchPagination\n  };\n}\nfunction useLoadMore(args) {\n  var _useState = useState(false),\n    isLoadingMore = _useState[0],\n    setIsLoadingMore = _useState[1];\n  var observer = {\n    start: function start() {\n      return setIsLoadingMore(true);\n    },\n    complete: function complete() {\n      return setIsLoadingMore(false);\n    },\n    error: function error() {\n      return setIsLoadingMore(false);\n    }\n  };\n  var handleReset = function handleReset() {\n    return setIsLoadingMore(false);\n  };\n  var _useLoadMoreFunction = useLoadMoreFunction((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, args), {}, {\n      observer: observer,\n      onReset: handleReset\n    })),\n    loadMore = _useLoadMoreFunction[0],\n    hasMore = _useLoadMoreFunction[1],\n    disposeFetch = _useLoadMoreFunction[2];\n  return [loadMore, hasMore, isLoadingMore, disposeFetch];\n}\nfunction usePaginationFragment(fragmentInput, parentFragmentRef) {\n  var impl = HooksImplementation.get();\n  if (impl) {\n    return impl.usePaginationFragment(fragmentInput, parentFragmentRef);\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return usePaginationFragment_LEGACY(fragmentInput, parentFragmentRef);\n  }\n}\nmodule.exports = usePaginationFragment;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _require = require('./loadQuery'),\n  useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\nvar useLazyLoadQueryNode = require('./useLazyLoadQueryNode');\nvar useMemoOperationDescriptor = require('./useMemoOperationDescriptor');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar invariant = require('invariant');\nvar _require2 = require('react'),\n  useDebugValue = _require2.useDebugValue;\nvar _require3 = require('relay-runtime'),\n  _require3$__internal = _require3.__internal,\n  fetchQueryDeduped = _require3$__internal.fetchQueryDeduped,\n  fetchQuery = _require3$__internal.fetchQuery;\nvar warning = require(\"fbjs/lib/warning\");\nfunction usePreloadedQuery(gqlQuery, preloadedQuery, options) {\n  // We need to use this hook in order to be able to track if\n  // loadQuery was called during render\n  useTrackLoadQueryInRender();\n  var environment = useRelayEnvironment();\n  var fetchKey = preloadedQuery.fetchKey,\n    fetchPolicy = preloadedQuery.fetchPolicy,\n    source = preloadedQuery.source,\n    variables = preloadedQuery.variables,\n    networkCacheConfig = preloadedQuery.networkCacheConfig;\n  var operation = useMemoOperationDescriptor(gqlQuery, variables, networkCacheConfig);\n  var useLazyLoadQueryNodeParams;\n  if (preloadedQuery.kind === 'PreloadedQuery_DEPRECATED') {\n    !(operation.request.node.params.name === preloadedQuery.name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'usePreloadedQuery(): Expected data to be prefetched for query `%s`, ' + 'got prefetch results for query `%s`.', operation.request.node.params.name, preloadedQuery.name) : invariant(false) : void 0;\n    useLazyLoadQueryNodeParams = {\n      componentDisplayName: 'usePreloadedQuery()',\n      fetchKey: fetchKey,\n      fetchObservable: fetchQueryDeduped(environment, operation.request.identifier, function () {\n        if (environment === preloadedQuery.environment && source != null) {\n          return environment.executeWithSource({\n            operation: operation,\n            source: source\n          });\n        } else {\n          return environment.execute({\n            operation: operation\n          });\n        }\n      }),\n      fetchPolicy: fetchPolicy,\n      query: operation,\n      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy\n    };\n  } else {\n    process.env.NODE_ENV !== \"production\" ? warning(preloadedQuery.isDisposed === false, 'usePreloadedQuery(): Expected preloadedQuery to not be disposed yet. ' + 'This is because disposing the query marks it for future garbage ' + 'collection, and as such query results may no longer be present in the Relay ' + 'store. In the future, this will become a hard error.') : void 0;\n    var fallbackFetchObservable = fetchQuery(environment, operation);\n    var fetchObservable;\n    if (source != null && environment === preloadedQuery.environment) {\n      // If the source observable exists and the environments match, reuse\n      // the source observable.\n      // If the source observable happens to be empty, we need to fall back\n      // and re-execute and de-dupe the query (at render time).\n      fetchObservable = source.ifEmpty(fallbackFetchObservable);\n    } else if (environment !== preloadedQuery.environment) {\n      // If a call to loadQuery is made with a particular environment, and that\n      // preloaded query is passed to usePreloadedQuery in a different environment\n      // context, we cannot re-use the existing preloaded query.\n      // Instead, we need to fall back and re-execute and de-dupe the query with\n      // the new environment (at render time).\n      // TODO T68036756 track occurences of this warning and turn it into a hard error\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'usePreloadedQuery(): usePreloadedQuery was passed a preloaded query ' + 'that was created with a different environment than the one that is currently ' + 'in context. In the future, this will become a hard error.') : void 0;\n      fetchObservable = fallbackFetchObservable;\n    } else {\n      // if (source == null)\n      // If the source observable does not exist, we need to\n      // fall back and re-execute and de-dupe the query (at render time).\n      fetchObservable = fallbackFetchObservable;\n    }\n    useLazyLoadQueryNodeParams = {\n      componentDisplayName: 'usePreloadedQuery()',\n      fetchObservable: fetchObservable,\n      fetchKey: fetchKey,\n      fetchPolicy: fetchPolicy,\n      query: operation,\n      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy\n    };\n  }\n  var data = useLazyLoadQueryNode(useLazyLoadQueryNodeParams);\n  if (process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue({\n      query: preloadedQuery.name,\n      variables: preloadedQuery.variables,\n      data: data,\n      fetchKey: fetchKey,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy\n    });\n  }\n  return data;\n}\nmodule.exports = usePreloadedQuery;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\nvar _require = require('./loadQuery'),\n  loadQuery = _require.loadQuery,\n  useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\nvar useIsMountedRef = require('./useIsMountedRef');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar _require2 = require('react'),\n  useCallback = _require2.useCallback,\n  useEffect = _require2.useEffect,\n  useRef = _require2.useRef,\n  useState = _require2.useState;\nvar _require3 = require('relay-runtime'),\n  getRequest = _require3.getRequest;\nvar initialNullQueryReferenceState = {\n  kind: 'NullQueryReference'\n};\nfunction requestIsLiveQuery(preloadableRequest) {\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    return preloadableRequest.params.metadata.live !== undefined;\n  }\n  var request = getRequest(preloadableRequest);\n  return request.params.metadata.live !== undefined;\n}\nfunction useQueryLoader(preloadableRequest, initialQueryReference) {\n  /**\n   * We want to always call `queryReference.dispose()` for every call to\n   * `setQueryReference(loadQuery(...))` so that no leaks of data in Relay stores\n   * will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each\n   * ref with `useEffect(() => () => queryReference.dispose(), [queryReference])`.\n   *\n   * Instead, we keep track of each call to `loadQuery` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded query references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * query references.\n   */\n\n  var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;\n  var environment = useRelayEnvironment();\n  useTrackLoadQueryInRender();\n  var isMountedRef = useIsMountedRef();\n  var undisposedQueryReferencesRef = useRef(new Set([initialQueryReferenceInternal]));\n  var _useState = useState(function () {\n      return initialQueryReferenceInternal;\n    }),\n    queryReference = _useState[0],\n    setQueryReference = _useState[1];\n  var _useState2 = useState(function () {\n      return initialQueryReferenceInternal;\n    }),\n    previousInitialQueryReference = _useState2[0],\n    setPreviousInitialQueryReference = _useState2[1];\n  if (initialQueryReferenceInternal !== previousInitialQueryReference) {\n    // Rendering the query reference makes it \"managed\" by this hook, so\n    // we start keeping track of it so we can dispose it when it is no longer\n    // necessary here\n    // TODO(T78446637): Handle disposal of managed query references in\n    // components that were never mounted after rendering\n    undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);\n    setPreviousInitialQueryReference(initialQueryReferenceInternal);\n    setQueryReference(initialQueryReferenceInternal);\n  }\n  var disposeQuery = useCallback(function () {\n    if (isMountedRef.current) {\n      undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);\n      setQueryReference(initialNullQueryReferenceState);\n    }\n  }, [isMountedRef]);\n  var queryLoaderCallback = useCallback(function (variables, options) {\n    var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {\n      fetchPolicy: options.fetchPolicy,\n      networkCacheConfig: options.networkCacheConfig,\n      __nameForWarning: options.__nameForWarning\n    } : options;\n    if (isMountedRef.current) {\n      var _options$__environmen;\n      var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);\n      undisposedQueryReferencesRef.current.add(updatedQueryReference);\n      setQueryReference(updatedQueryReference);\n    }\n  }, [environment, preloadableRequest, setQueryReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current queryReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current queryReference disposed, we need to load the query again\n      // and force a re-render by calling queryLoaderCallback again,\n      // so that the queryReference is correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n      if (queryReference.kind !== 'NullQueryReference') {\n        queryLoaderCallback(queryReference.variables, {\n          fetchPolicy: queryReference.fetchPolicy,\n          networkCacheConfig: queryReference.networkCacheConfig\n        });\n      }\n      return;\n    }\n\n    // When a new queryReference is committed, we iterate over all\n    // query references in undisposedQueryReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling query references for the\n    // case that loadQuery is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedQueryReferences until we find queryReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find queryReference in the set, because if a\n    // state update results in a commit, no state updates initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with updates that were scheduled prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n    var undisposedQueryReferences = undisposedQueryReferencesRef.current;\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferences),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedQueryReference = _step.value;\n          if (undisposedQueryReference === queryReference) {\n            break;\n          }\n          undisposedQueryReferences[\"delete\"](undisposedQueryReference);\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [queryReference, isMountedRef, queryLoaderCallback, preloadableRequest]);\n  useEffect(function () {\n    return function disposeAllRemainingQueryReferences() {\n      // undisposedQueryReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferencesRef.current),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var undisposedQueryReference = _step2.value;\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [preloadableRequest]);\n  return [queryReference.kind === 'NullQueryReference' ? null : queryReference, queryLoaderCallback, disposeQuery];\n}\nmodule.exports = useQueryLoader;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar HooksImplementation = require('./HooksImplementation');\nvar useRefetchableFragmentNode = require('./useRefetchableFragmentNode');\nvar useStaticFragmentNodeWarning = require('./useStaticFragmentNodeWarning');\nvar _require = require('react'),\n  useDebugValue = _require.useDebugValue;\nvar _require2 = require('relay-runtime'),\n  getFragment = _require2.getFragment;\nfunction useRefetchableFragment_LEGACY(fragmentInput, fragmentRef) {\n  var fragmentNode = getFragment(fragmentInput);\n  useStaticFragmentNodeWarning(fragmentNode, 'first argument of useRefetchableFragment()');\n  var _useRefetchableFragme = useRefetchableFragmentNode(fragmentNode, fragmentRef, 'useRefetchableFragment()'),\n    fragmentData = _useRefetchableFragme.fragmentData,\n    refetch = _useRefetchableFragme.refetch;\n  if (process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue({\n      fragment: fragmentNode.name,\n      data: fragmentData\n    });\n  }\n\n  // $FlowFixMe[incompatible-return]\n  // $FlowFixMe[prop-missing]\n  return [fragmentData, refetch];\n}\nfunction useRefetchableFragment(fragmentInput, parentFragmentRef) {\n  var impl = HooksImplementation.get();\n  if (impl) {\n    return impl.useRefetchableFragment(fragmentInput, parentFragmentRef);\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useRefetchableFragment_LEGACY(fragmentInput, parentFragmentRef);\n  }\n}\nmodule.exports = useRefetchableFragment;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\")[\"default\"];\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _require = require('./FragmentResource'),\n  getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;\nvar ProfilerContext = require('./ProfilerContext');\nvar _require2 = require('./QueryResource'),\n  getQueryResourceForEnvironment = _require2.getQueryResourceForEnvironment;\nvar useFragmentNode = require('./useFragmentNode');\nvar useIsMountedRef = require('./useIsMountedRef');\nvar useQueryLoader = require('./useQueryLoader');\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar invariant = require('invariant');\nvar _require3 = require('react'),\n  useCallback = _require3.useCallback,\n  useContext = _require3.useContext,\n  useReducer = _require3.useReducer;\nvar _require4 = require('relay-runtime'),\n  fetchQuery = _require4.__internal.fetchQuery,\n  createOperationDescriptor = _require4.createOperationDescriptor,\n  getFragmentIdentifier = _require4.getFragmentIdentifier,\n  getRefetchMetadata = _require4.getRefetchMetadata,\n  getSelector = _require4.getSelector,\n  getValueAtPath = _require4.getValueAtPath;\nvar warning = require(\"fbjs/lib/warning\");\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'refetch':\n      {\n        var _action$refetchEnviro;\n        return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, state), {}, {\n          fetchPolicy: action.fetchPolicy,\n          mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,\n          onComplete: action.onComplete,\n          refetchEnvironment: action.refetchEnvironment,\n          refetchQuery: action.refetchQuery,\n          renderPolicy: action.renderPolicy\n        });\n      }\n    case 'reset':\n      {\n        return {\n          fetchPolicy: undefined,\n          mirroredEnvironment: action.environment,\n          mirroredFragmentIdentifier: action.fragmentIdentifier,\n          onComplete: undefined,\n          refetchQuery: null,\n          renderPolicy: undefined\n        };\n      }\n    default:\n      {\n        action.type;\n        throw new Error('useRefetchableFragmentNode: Unexpected action type');\n      }\n  }\n}\nfunction useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {\n  var parentEnvironment = useRelayEnvironment();\n  var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName),\n    refetchableRequest = _getRefetchMetadata.refetchableRequest,\n    fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse,\n    identifierField = _getRefetchMetadata.identifierField;\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);\n  var _useReducer = useReducer(reducer, {\n      fetchPolicy: undefined,\n      mirroredEnvironment: parentEnvironment,\n      mirroredFragmentIdentifier: fragmentIdentifier,\n      onComplete: undefined,\n      refetchEnvironment: null,\n      refetchQuery: null,\n      renderPolicy: undefined\n    }),\n    refetchState = _useReducer[0],\n    dispatch = _useReducer[1];\n  var fetchPolicy = refetchState.fetchPolicy,\n    mirroredEnvironment = refetchState.mirroredEnvironment,\n    mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier,\n    onComplete = refetchState.onComplete,\n    refetchEnvironment = refetchState.refetchEnvironment,\n    refetchQuery = refetchState.refetchQuery,\n    renderPolicy = refetchState.renderPolicy;\n  var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;\n  var QueryResource = getQueryResourceForEnvironment(environment);\n  var FragmentResource = getFragmentResourceForEnvironment(environment);\n  var profilerContext = useContext(ProfilerContext);\n  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;\n  var _useQueryLoader = useQueryLoader(refetchableRequest),\n    queryRef = _useQueryLoader[0],\n    loadQuery = _useQueryLoader[1],\n    disposeQuery = _useQueryLoader[2];\n  var fragmentRef = parentFragmentRef;\n  if (shouldReset) {\n    dispatch({\n      type: 'reset',\n      environment: environment,\n      fragmentIdentifier: fragmentIdentifier\n    });\n    disposeQuery();\n  } else if (refetchQuery != null && queryRef != null) {\n    // If refetch was called, we expect to have a refetchQuery and queryRef\n    // in state, since both state updates to set the refetchQuery and the\n    // queryRef occur simultaneously.\n    // In this case, we need to read the refetched query data (potentially\n    // suspending if it's in flight), and extract the new fragment ref\n    // from the query in order read the current @refetchable fragment\n    // with the updated fragment owner as the new refetchQuery.\n\n    // Before observing the refetch, record the current ID and typename\n    // so that, if we are refetching existing data on\n    // a field that implements Node, after refetching we\n    // can validate that the received data is consistent\n    var debugPreviousIDAndTypename;\n    if (process.env.NODE_ENV !== \"production\") {\n      debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, environment);\n    }\n    var handleQueryCompleted = function handleQueryCompleted(maybeError) {\n      onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);\n    };\n\n    // The queryRef.source obtained from useQueryLoader will be\n    // an observable we can consume /if/ a network request was\n    // started. Otherwise, given that QueryResource.prepare\n    // always expects an observable we fall back to a new network\n    // observable. Note however that if loadQuery did not make a network\n    // request, we don't expect to make one here, unless the state of\n    // the cache has changed between the call to refetch and this\n    // render.\n    var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery);\n\n    // Now wwe can we read the refetch query here using the\n    // queryRef provided from useQueryLoader. Note that the\n    // network request is started during the call to refetch,\n    // but if the refetch query is still in flight, we will suspend\n    // at this point:\n    var queryResult = profilerContext.wrapPrepareQueryResource(function () {\n      return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {\n        error: handleQueryCompleted,\n        complete: function complete() {\n          // Validate that the type of the object we got back matches the type\n          // of the object already in the store\n          if (process.env.NODE_ENV !== \"production\") {\n            debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);\n          }\n          handleQueryCompleted();\n        }\n      }, queryRef.fetchKey, profilerContext);\n    });\n    var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;\n    !(queryData != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    // After reading/fetching the refetch query, we extract from the\n    // refetch query response the new fragment ref we need to use to read\n    // the fragment. The new fragment ref will point to the refetch query\n    // as its fragment owner.\n    var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);\n    fragmentRef = refetchedFragmentRef;\n    if (process.env.NODE_ENV !== \"production\") {\n      // Validate that the id of the object we got back matches the id\n      // we queried for in the variables.\n      // We do this during render instead of onComplete to make sure we are\n      // only validating the most recent refetch.\n      debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);\n    }\n  }\n\n  // We read and subscribe to the fragment using useFragmentNode.\n  // If refetch was called, we read the fragment using the new computed\n  // fragment ref from the refetch query response; otherwise, we use the\n  // fragment ref passed by the caller as normal.\n  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),\n    fragmentData = _useFragmentNode.data,\n    disableStoreUpdates = _useFragmentNode.disableStoreUpdates,\n    enableStoreUpdates = _useFragmentNode.enableStoreUpdates;\n  var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest);\n  return {\n    fragmentData: fragmentData,\n    fragmentRef: fragmentRef,\n    refetch: refetch,\n    disableStoreUpdates: disableStoreUpdates,\n    enableStoreUpdates: enableStoreUpdates\n  };\n}\nfunction useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest) {\n  var isMountedRef = useIsMountedRef();\n  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;\n  return useCallback(function (providedRefetchVariables, options) {\n    // Bail out and warn if we're trying to refetch after the component\n    // has unmounted\n    if (isMountedRef.current !== true) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;\n      return {\n        dispose: function dispose() {}\n      };\n    }\n    if (parentFragmentRef == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + \"initial fragment data to be non-null. Please make sure you're \" + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n    }\n    var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;\n    var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;\n    var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;\n    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;\n    var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);\n    var parentVariables;\n    var fragmentVariables;\n    if (fragmentSelector == null) {\n      parentVariables = {};\n      fragmentVariables = {};\n    } else if (fragmentSelector.kind === 'PluralReaderSelector') {\n      var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;\n      parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};\n      fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};\n    } else {\n      parentVariables = fragmentSelector.owner.variables;\n      fragmentVariables = fragmentSelector.variables;\n    }\n\n    // A user of `useRefetchableFragment()` may pass a subset of\n    // all variables required by the fragment when calling `refetch()`.\n    // We fill in any variables not passed by the call to `refetch()` with the\n    // variables from the original parent fragment owner.\n    var refetchVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, parentVariables), fragmentVariables), providedRefetchVariables);\n\n    // If the query needs an identifier value ('id' or similar) and one\n    // was not explicitly provided, read it from the fragment data.\n    if (identifierField != null && !providedRefetchVariables.hasOwnProperty('id')) {\n      // @refetchable fragments are guaranteed to have an `id` selection\n      // if the type is Node, implements Node, or is @fetchable. Double-check\n      // that there actually is a value at runtime.\n      if (typeof identifierValue !== 'string') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;\n      }\n      refetchVariables.id = identifierValue;\n    }\n    var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {\n      force: true\n    });\n\n    // We call loadQuery which will start a network request if necessary\n    // and update the querRef from useQueryLoader.\n    // Note the following:\n    // - loadQuery will dispose of any previously refetched queries.\n    // - We use the variables extracted off the OperationDescriptor\n    // so that they have been filtered out to include only the\n    // variables actually declared in the query.\n    loadQuery(refetchQuery.request.variables, {\n      fetchPolicy: fetchPolicy,\n      __environment: refetchEnvironment,\n      __nameForWarning: 'refetch'\n    });\n    dispatch({\n      type: 'refetch',\n      fetchPolicy: fetchPolicy,\n      onComplete: onComplete,\n      refetchEnvironment: refetchEnvironment,\n      refetchQuery: refetchQuery,\n      renderPolicy: renderPolicy\n    });\n    return {\n      dispose: disposeQuery\n    };\n  },\n  // NOTE: We disable react-hooks-deps warning because:\n  //   - We know fragmentRefPathInResponse is static, so it can be omitted from\n  //     deps\n  //   - We know fragmentNode is static, so it can be omitted from deps.\n  //   - fragmentNode and parentFragmentRef are also captured by including\n  //     fragmentIdentifier\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [fragmentIdentifier, dispatch, disposeQuery, identifierValue, loadQuery]);\n}\nvar debugFunctions;\nif (process.env.NODE_ENV !== \"production\") {\n  debugFunctions = {\n    getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, environment) {\n      var _require5 = require('relay-runtime'),\n        Record = _require5.Record;\n      var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables.id;\n      if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {\n        return null;\n      }\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(id);\n      var typename = record && Record.getType(record);\n      if (typename == null) {\n        return null;\n      }\n      return {\n        id: id,\n        typename: typename\n      };\n    },\n    checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {\n      var _require6 = require('relay-runtime'),\n        Record = _require6.Record;\n      if (!previousIDAndType) {\n        return;\n      }\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(previousIDAndType.id);\n      var typename = record && Record.getType(record);\n      if (typename !== previousIDAndType.typename) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    },\n    checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {\n      if (previousIDAndTypename == null) {\n        return;\n      }\n      var _require7 = require('relay-runtime'),\n        ID_KEY = _require7.ID_KEY;\n      // $FlowExpectedError[incompatible-use]\n      var resultID = refetchedFragmentRef[ID_KEY];\n      if (resultID != null && resultID !== previousIDAndTypename.id) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    }\n  };\n}\nmodule.exports = useRefetchableFragmentNode;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar ReactRelayContext = require('./../ReactRelayContext');\nvar invariant = require('invariant');\nvar _require = require('react'),\n  useContext = _require.useContext;\nfunction useRelayEnvironment() {\n  var context = useContext(ReactRelayContext);\n  !(context != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'useRelayEnvironment: Expected to have found a Relay environment provided by ' + 'a `RelayEnvironmentProvider` component. ' + 'This usually means that useRelayEnvironment was used in a ' + 'component that is not a descendant of a `RelayEnvironmentProvider`. ' + 'Please make sure a `RelayEnvironmentProvider` has been rendered somewhere ' + 'as a parent or ancestor of your component.') : invariant(false) : void 0;\n  return context.environment;\n}\nmodule.exports = useRelayEnvironment;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar useUnsafeRef_DEPRECATED = require('./useUnsafeRef_DEPRECATED');\nvar warning = require(\"fbjs/lib/warning\");\nfunction useStaticFragmentNodeWarning(fragmentNode, warningContext) {\n  if (process.env.NODE_ENV !== \"production\") {\n    // This is calling `useRef` conditionally, but based on the environment\n    // __DEV__ setting which shouldn't change. This allows us to only pay the\n    // cost of `useRef` in development mode to produce the warning.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    var initialPropRef = useUnsafeRef_DEPRECATED(fragmentNode.name);\n    process.env.NODE_ENV !== \"production\" ? warning(initialPropRef.current === fragmentNode.name, 'Relay: The %s has to remain the same over the lifetime of a component. ' + 'Changing it is not supported and will result in unexpected behavior.', warningContext) : void 0;\n  }\n}\nmodule.exports = useStaticFragmentNodeWarning;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar _require = require('react'),\n  useEffect = _require.useEffect,\n  useRef = _require.useRef;\n\n/**\n * This hook subscribes a callback to the invalidation state of the given data\n * ids.\n * Any time the invalidation state of the given data ids changes, the provided\n * callback will be called.\n * If new ids or a new callback are provided, the subscription will be\n * re-established and the previous one will be disposed.\n * The subscription will automatically be disposed on unmount\n */\nfunction useSubscribeToInvalidationState(dataIDs, callback) {\n  var environment = useRelayEnvironment();\n  var disposableRef = useRef(null);\n  var stableDataIDs = Array.from(dataIDs).sort().join('');\n  useEffect(function () {\n    var store = environment.getStore();\n    var invalidationState = store.lookupInvalidationState(dataIDs);\n    var disposable = store.subscribeToInvalidationState(invalidationState, callback);\n    disposableRef.current = disposable;\n    return function () {\n      return disposable.dispose();\n    };\n\n    // Intentionally excluding dataIDs, since we're using stableDataIDs\n    // instead\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [stableDataIDs, callback, environment]);\n  return {\n    dispose: function dispose() {\n      if (disposableRef.current != null) {\n        disposableRef.current.dispose();\n      }\n    }\n  };\n}\nmodule.exports = useSubscribeToInvalidationState;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\nvar _require = require('react'),\n  useEffect = _require.useEffect;\nvar _require2 = require('relay-runtime'),\n  requestSubscription = _require2.requestSubscription;\nfunction useSubscription(config, requestSubscriptionFn) {\n  // N.B. this will re-subscribe every render if config or requestSubscriptionFn\n  // are not memoized.\n  // Please do not pass an object defined in-line.\n  var actualRequestSubscription = requestSubscriptionFn !== null && requestSubscriptionFn !== void 0 ? requestSubscriptionFn : requestSubscription;\n  var environment = useRelayEnvironment();\n  useEffect(function () {\n    // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n    var _actualRequestSubscri = actualRequestSubscription(environment, config),\n      dispose = _actualRequestSubscri.dispose;\n    return dispose;\n  }, [environment, config, actualRequestSubscription]);\n}\nmodule.exports = useSubscription;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall relay\n */\n\n'use strict';\n\nvar _require = require('react'),\n  useMemo = _require.useMemo;\n\n/**\n * Like `useRef`, but does not warn when accessed during render. It's a bad\n * pattern to read or write from a ref during render as it does not trigger\n * a rerender and might result in bugs.\n */\nfunction useUnsafeRef_DEPRECATED(init) {\n  return useMemo(function () {\n    return {\n      current: init\n    };\n  }, []);\n}\nmodule.exports = useUnsafeRef_DEPRECATED;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _extends() {\n  module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _extends.apply(this, arguments);\n}\nmodule.exports = _extends, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var setPrototypeOf = require(\"./setPrototypeOf.js\");\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}\nmodule.exports = _inheritsLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["Object","value","exports","path","locale","locales","domainLocales","__esModule","defineProperty","assign","module","_interop_require_default","require","_object_without_properties_loose","_react","_resolveHref","_isLocalUrl","_formatUrl","_utils","_addLocale","_routerContext","_appRouterContext","_useIntersection","_getDomainLocale","_addBasePath","prefetched","Set","prefetch","router","href","as","options","isAppRouter","isLocalURL","bypassPrefetchedCheck","prefetchedKey","undefined","has","add","resolve","err","formatStringOrUrl","urlObjOrString","formatUrl","Link","forwardRef","props","forwardedRef","children","child","hrefProp","asProp","childrenProp","prefetchProp","passHref","replace","shallow","scroll","onClick","onMouseEnterProp","onMouseEnter","onTouchStartProp","onTouchStart","_props$legacyBehavior","legacyBehavior","restProps","createElement","prefetchEnabled","pagesRouter","useContext","RouterContext","appRouter","AppRouterContext","_react$default$useMem","useMemo","resolvedHref","_resolveHref3","_slicedToArray","resolveHref","resolvedAs","previousHref","useRef","previousAs","Children","only","childRef","ref","_useIntersection3","useIntersection","rootMargin","setIntersectionRef","isVisible","resetVisible","setRef","useCallback","el","current","useEffect","childProps","e","defaultPrevented","linkClicked","isAnchorNodeName","nodeName","currentTarget","toUpperCase","isModifiedEvent","target","eventTarget","getAttribute","event","metaKey","ctrlKey","shiftKey","altKey","nativeEvent","which","preventDefault","navigate","forceOptimisticNavigation","startTransition","priority","isAbsoluteUrl","type","curLocale","localeDomain","isLocaleDomain","getDomainLocale","addBasePath","addLocale","defaultLocale","cloneElement","_ref","rootRef","isDisabled","disabled","hasIntersectionObserver","_useState2","useState","visible","setVisible","elementRef","setElement","element","_createObserver","id","observer","elements","tagName","createObserver","instance","root","margin","existing","idList","find","obj","observers","get","Map","IntersectionObserver","entries","forEach","entry","callback","isIntersecting","intersectionRatio","push","set","observe","unobserve","size","disconnect","index","findIndex","splice","idleCallback","requestIdleCallback","cancelIdleCallback","_requestIdleCallback","__webpack_require__","getComponentName","component","displayName","name","getContainerName","Component","React","createRelayContext","_require","__internal","_interopRequireDefault","_objectSpread2","_objectWithoutPropertiesLoose2","_assertThisInitialized2","_inheritsLoose2","_defineProperty2","_excluded","buildReactRelayContainer","assertRelayContext","_require2","areEqual","_require3","createFragmentSpecResolver","getDataIDsFromObject","isScalarAndEqual","createContainerWithFragments","fragments","_class","containerName","_React$Component","_this","call","resolverFromThisUpdate","state","resolver","setState","updatedState","data","relayProp","getRelayProp","environment","_props$__rootIsQueryR","relayContext","__relayContext","rootIsQueryRenderer","__rootIsQueryRenderer","prevProps","prevPropsContext","getDerivedStateFromProps","nextProps","prevState","_nextProps$__rootIsQu","prevIDs","nextIDs","setProps","_proto","prototype","componentDidMount","_subscribeToNewResolverAndRerenderIfStoreHasChanged","componentDidUpdate","dispose","_rerenderIfStoreHasChanged","componentWillUnmount","shouldComponentUpdate","nextState","keys","ii","length","key","hasOwnProperty","_this$state","maybeNewData","_this$state2","setCallback","_handleFragmentDataUpdate","render","_this$props","componentRef","relay","createContainer","fragmentSpec","ReactRelayContext","ReactRelayQueryRendererContext","createOperationDescriptor","getRequest","deepFreeze","useLayoutEffect","queryRendererContext","latestValue","query","variables","latestVariables","operation","dataRef","forceUpdate","_useState","cleanupFnRef","cleanupFn","check","res","lookup","fragment","retainDisposable","retain","subscribeDisposable","subscribe","newSnapshot","disposed","Provider","_extends2","_objectSpread3","_excluded2","_excluded3","getRootVariablesForFragments","ReactRelayQueryFetcher","invariant","ConnectionInterface","Observable","RelayFeatureFlags","getVariablesFromObject","FORWARD","toObserver","observerOrCallback","error","complete","unsubscribe","subscription","connectionConfig","ComponentClass","countVariable","metadata","getConnectionFromProps","direction","getFragmentVariables","findConnectionMetadata","foundConnectionMetadata","isRelayModern","fragmentName","connectionMetadata","connection","i","count","prevVars","totalCount","_resolver","connectionData","_getConnectionData","hasMore","cursor","_refetchSubscription","refetchVariables","_canFetchPage","_refetchVariables","fetch","_fetchPage","force","pageSize","create","sink","edgeCount","_refetchConnection","_ConnectionInterface$","END_CURSOR","START_CURSOR","_isARequestInFlight","ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT","prevContext","contextForChildren","_buildRelayProp","resolverGeneration","_isUnmounted","_hasFetched","UNSAFE_componentWillReceiveProps","_this2","prevRootVariables","nextRootVariables","_cleanup","_hasMore","isLoading","_isLoading","loadMore","_loadMore","refetchConnection","_ConnectionInterface$2","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","edges","pageInfo","Array","isArray","_getQueryFetcher","_queryFetcher","method","paginatingVariables","fragmentVariables","_this3","_assertRelayContext","_this$props2","rootVariables","fetchVariables","getVariables","cacheConfig","refetchSubscription","onNext","payload","prevData","setVariables","request","node","nextData","cleanup","execute","preservePreviousReferences","mergeMap","next","_this$props3","fetchQuery","isRelayModernEnvironment","args","_cacheSelectionReference","cacheSelectionReference","_selectionReferences","selectionReferences","getSelectionReferences","lookupInStore","fetchPolicy","status","_retainCachedOperation","getFetchResult","_didFetchFinish","_error","_snapshot","snapshot","_ref$preservePrevious","reference","concat","disposeSelectionReferences","setOnDataChange","onDataChange","_fetchOptions","onDataChangeCallbacks","fetchOptions","cacheConfigOverride","fetchHasReturned","disposeRequest","oldOnDataChangeCallbacks","indexOf","operationOverride","_pendingRequest","_onQueryDataAvailable","notifyFirstResult","retry","_rootSubscription","_disposeCacheSelectionReference","r","_ref2","_this$_fetchOptions","maybeNewOnDataChangeCallbacks","requestCache","ReactRelayQueryRenderer","params","prevRequestCacheKey","requestCacheKey","renderProps","getRenderProps","queryFetcher","retryCallbacks","handleDataChange","handleRetryAfterError","getRequestCacheKey","_maybeHiddenOrFastRefresh","prevPropsEnvironment","prevPropsVariables","prevQuery","fetchQueryAndComputeStateFromProps","resetQueryStateForUpdate","newState","ENABLE_QUERY_RENDERER_SET_STATE_PREVENTION","fetchResult","_fetchResult$snapshot","_fetchResult$error","_handleDataChange","getLoadingRenderProps","_prevProps","_this$state3","syncSnapshot","JSON","stringify","cacheID","prevSelectionReferences","storeSnapshot","querySnapshot","createContext","refetch","taggedNode","renderVariables","_getFragmentVariables","localVariables","latestState","response","start","_refetch","isRelayEnvironment","isRelayContext","context","componentName","assertFragmentMap","getFragment","Container","_queryRendererContext","getSelector","_selector$selectors$","_selector$selectors$2","_selector$owner$varia","selector","fragmentOwnerVariables","kind","selectors","owner","ReactRelayFragmentContainer","ReactRelayLocalQueryRenderer","ReactRelayPaginationContainer","ReactRelayRefetchContainer","EntryPointContainer","loadEntryPoint","loadQuery","ProfilerContext","RelayEnvironmentProvider","useClientQuery","useEntryPointLoader","useFragment","useLazyLoadQuery","useMutation","usePaginationFragment","usePreloadedQuery","useQueryLoader","useRefetchableFragment","useRelayEnvironment","useSubscribeToInvalidationState","useSubscription","RelayRuntime","ConnectionHandler","QueryRenderer","LocalQueryRenderer","MutationTypes","RangeOperations","applyOptimisticMutation","commitLocalUpdate","commitMutation","createFragmentContainer","createPaginationContainer","createRefetchContainer","fetchQuery_DEPRECATED","graphql","readInlineData","requestSubscription","entryPointReference","getComponent","queries","entryPoints","extraProps","rootModuleID","profilerContext","__log","_toConsumableArray2","LRUCache","getQueryResourceForEnvironment","SuspenseResource","_require2$__internal","getPromiseForActiveRequest","getFragmentIdentifier","getPendingOperationsForFragment","getVariablesFromFragment","handlePotentialSnapshotErrors","isPromise","recycleNodesInto","WEAKMAP_SUPPORTED","WeakMap","CONSTANT_READONLY_EMPTY_ARRAY","freeze","isMissingData","some","s","missingLiveResolverFields","map","filter","Boolean","flat","getFragmentResult","cacheKey","storeEpoch","ClientEdgeQueryResultsCache","_environment","fragmentIdentifier","_this$_cache$get$","_this$_cache$get","_cache","recordQueryResults","existingResults","_suspenseResource","queryResult","temporaryRetain","suspenseResource","_retain","_this$_retainCounts$g","retainCount","_retainCounts","_this$_retainCounts$g2","newRetainCount","FragmentResourceImpl","ENABLE_CLIENT_EDGES","_clientEdgeQueryResultsCache","_proto2","read","fragmentNode","fragmentRef","componentDisplayName","fragmentKey","readWithIdentifier","getStore","getEpoch","_fragmentNode$metadat","plural","cachedValue","promise","result","isRelayHooks","isPromiseCached","pendingOperations","_missingLiveResolverF","_throwOrLogErrorsInSnapshot","cached","fragmentSelector","fragmentResult","clientEdgeRequests","_fragmentNode$metadat2","hasClientEdges","_s$missingClientEdges","_s$missingClientEdges2","missingClientEdges","_snapshot$missingClie","_snapshot$missingClie2","f","queryResource","queryResults","snap","_snap$missingClientEd","_clientEdgeRequests","clientEdgeDestinationID","_this3$_performClient","_performClientEdgeQuery","requestDescriptor","clientEdgePromises","fragmentOwner","parentQueryPromiseResult","_getAndSavePromiseForFragmentRequestInFlight","parentQueryPromiseResultPromise","missingResolverFieldPromises","_missingLiveResolverF2","_missingLiveResolverF3","liveStateID","store","getLiveResolverPromise","_parentQueryPromiseRe","_clientEdgeRequests2","promises","Promise","all","originalVariables","fetchObservable","prepare","_this4","missingRequiredFields","relayResolverErrors","readSpec","fragmentNodes","fragmentRefs","_this5","renderedSnapshot","_this$checkMissedUpda","checkMissedUpdates","didMissUpdates","currentSnapshot","disposables","idx","latestSnapshot","_updatePluralSnapshot","_this$_clientEdgeQuer","_this$_clientEdgeQuer2","clientEdgeQueryResults","subscribeSpec","fragmentResults","_this6","disposable","currentSnapshots","renderData","currentData","updatedData","updatedCurrentSnapshot","seenRecords","checkMissedUpdatesSpec","_this7","_this8","pendingOperationsResult","networkPromise","then","baseSnapshots","_currentFragmentResul","currentFragmentResult","nextSnapshots","createFragmentResource","dataResources","getFragmentResourceForEnvironment","newDataResource","implementation","inject","impl","capacity","_capacity","_map","firstKey","done","clear","wrapPrepareQueryResource","cb","DEFAULT_FETCH_POLICY","DEFAULT_LIVE_FETCH_POLICY","operationIsLiveQuery","live","getQueryCacheIdentifier","maybeFetchPolicy","maybeRenderPolicy","cacheBreaker","renderPolicy","UNSTABLE_getDefaultRenderPolicy","cacheIdentifier","identifier","getQueryResult","rootFragmentRef","__id","dataID","__fragments","__fragmentOwner","nextID","createCacheEntry","operationAvailability","networkSubscription","onDispose","isLiveQuery","currentValue","currentNetworkSubscription","retention","cacheEntry","processedPayloadsCount","getValue","setValue","val","setNetworkSubscription","permanentRetain","releaseTemporaryRetain","QueryResourceImpl","prepareWithIdentifier","temporaryRetainDisposable","entryWasCached","_fetchAndSaveQuery","observerUnsubscribe","queryAvailability","Error","_getOrCreateCacheEntry","resourceID","TESTS_ONLY__getCacheEntry","_clearCacheEntry","queryStatus","hasFullQuery","canPartialRender","resolveNetworkPromise","shouldFetch","shouldAllowRender","_cacheEntry","_queryResult","observerStart","observerNext","observerError","observerComplete","_cacheEntry2","createQueryResource","getEnvironmentForActor","_retainCount","_retainDisposable","Math","max","_this$_releaseTempora","isServer","releaseQueryTimeout","clearTimeout","_releaseTemporaryRetain","setTimeout","_this$_releaseTempora2","_this$_releaseTempora3","getRetainCount","environmentProvider","entryPoint","entryPointParams","loadingPromise","getModuleIfRequired","load","preloadProps","getPreloadProps","preloadedQueries","preloadedEntryPoints","queriesPropNames","queryPropName","_queries$queryPropNam","environmentProviderOptions","parameters","getEnvironment","networkCacheConfig","__nameForWarning","entryPointPropNames","entryPointPropName","entryPointDescription","nestedEntryPoint","nestedParams","isDisposed","values","innerDispose","_loadingPromise","componentModule","getModuleId","fetchQueryDeduped","PreloadableQueryRegistry","ReplaySubject","getRequestIdentifier","RenderDispatcher","fetchKey","preloadableRequest","_React$__SECRET_INTER3","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","_React$__SECRET_INTER4","ReactCurrentDispatcher","_options$fetchPolicy","retainReference","unsubscribeFromNetworkRequest","unsubscribeFromExecution","cancelOnLoadCallback","queryId","didExecuteNetworkSource","executeWithNetworkSource","networkObservable","executeWithSource","source","executionSubject","returnedObservable","networkError","didMakeNetworkRequest","makeNetworkRequest","subject","_observable$subscribe","ENABLE_LOAD_QUERY_REQUEST_DEDUPING","network","getNetwork","subjectSubscription","executeDeduped","fetchFn","_fetchQueryDeduped$su","checkAvailabilityAndExecute","concreteRequest","_params","preloadableConcreteRequest","_module","_PreloadableQueryRegi","onLoad","preloadedModule","isReleased","isNetworkRequestCancelled","releaseQuery","cancelNetworkRequest","useTrackLoadQueryInRender","_React$__SECRET_INTER","_React$__SECRET_INTER2","gqlQuery","_createForOfIteratorHelper2","useIsMountedRef","initialNullEntryPointReferenceState","_options$TEST_ONLY__i","_options$TEST_ONLY__i2","_options$TEST_ONLY__i3","_options$TEST_ONLY__i4","initialEntryPointReferenceInternal","TEST_ONLY__initialEntryPointData","initialEntryPointParamsInternal","isMountedRef","undisposedEntryPointReferencesRef","setEntryPointReference","setEntryPointParams","disposeEntryPoint","nullEntryPointReference","entryPointLoaderCallback","updatedEntryPointReference","maybeHiddenOrFastRefresh","undisposedEntryPointReferences","_step","_iterator","n","undisposedEntryPointReference","_step2","_iterator2","unhandledStateChange","useUnsafeRef_DEPRECATED","subscriptionRef","isFetchingRef","disposeFetch","startFetch","completeFetch","HooksImplementation","useFragmentNode","useStaticFragmentNodeWarning","useDebugValue","_useFragmentNode","FragmentResource","isListeningForUpdatesRef","handleDataUpdate","disableStoreUpdates","enableStoreUpdates","getObservableForActiveRequest","observable","isActive","setIsActive","onCompleteOrError","useLazyLoadQueryNode","useMemoOperationDescriptor","UNSTABLE_renderPolicy","useFetchTrackingRef","QueryResource","forceUpdateKey","_useFetchTrackingRef","preparedQueryResult","useIsOperationNodeActive","getPaginationVariables","getValueAtPath","fragmentData","connectionPathInFragmentData","paginationRequest","paginationMetadata","onReset","identifierField","identifierValue","mirroredEnvironment","setMirroredEnvironment","mirroredFragmentIdentifier","setMirroredFragmentIdentifier","isParentQueryActive","_getConnectionState","getConnectionState","_pageInfo$END_CURSOR","_pageInfo$START_CURSO","onComplete","parentVariables","extraVariables","UNSTABLE_extraVariables","paginationVariables","useMemoVariables","memoVariables","memoCacheConfig","mirroredVariables","setMirroredVariables","defaultCommitMutation","mutation","commitMutationFn","arguments","environmentRef","mutationRef","inFlightMutationsRef","isMutationInFlight","setMutationInFlight","config","onCompleted","errors","_config$onCompleted","onError","_config$onError","onUnsubscribe","_config$onUnsubscribe","_config$onNext","useLoadMoreFunction","useRefetchableFragmentNode","getPaginationMetadata","useLoadMore","isLoadingMore","setIsLoadingMore","_useLoadMoreFunction","fragmentInput","parentFragmentRef","_getPaginationMetadat","_useRefetchableFragme","_useLoadMore","loadPrevious","hasPrevious","isLoadingPrevious","disposeFetchPrevious","_useLoadMore2","loadNext","hasNext","isLoadingNext","disposeFetchNext","__environment","_require3$__internal","preloadedQuery","useLazyLoadQueryNodeParams","fallbackFetchObservable","ifEmpty","initialNullQueryReferenceState","requestIsLiveQuery","initialQueryReference","initialQueryReferenceInternal","undisposedQueryReferencesRef","queryReference","setQueryReference","previousInitialQueryReference","setPreviousInitialQueryReference","disposeQuery","queryLoaderCallback","mergedOptions","_options$__environmen","updatedQueryReference","undisposedQueryReferences","undisposedQueryReference","useReducer","_require4","getRefetchMetadata","reducer","action","_action$refetchEnviro","refetchEnvironment","refetchQuery","parentEnvironment","_getRefetchMetadata","refetchableRequest","fragmentRefPathInResponse","_useReducer","refetchState","dispatch","_useQueryLoader","queryRef","handleQueryCompleted","maybeError","queryData","providedRefetchVariables","_fragmentSelector$sel","_fragmentSelector$sel2","_fragmentSelector$sel3","_fragmentSelector$sel4","warningContext","dataIDs","disposableRef","invalidationState","lookupInvalidationState","subscribeToInvalidationState","from","sort","join","requestSubscriptionFn","actualRequestSubscription","_actualRequestSubscri","init","self","_extends","bind","apply","setPrototypeOf","subClass","superClass","constructor","excluded","sourceKeys","_setPrototypeOf","o","p","__proto__"],"sourceRoot":""}